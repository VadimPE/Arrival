## +Cal/TLA+
### Когда надо выбрать TLA+?
* В большинстве распределенных алгоритмов
* В алгоритме участвует среда
* Нам не надо моделировать процессы ([SI](https://github.com/will62794/snapshot-isolation-spec))
* Нам не нужна привязка к id процессов (Например, проверка Linearizability)

### Когда надо бырать +Cal?
* В большинстве параллельных алгоритмов
* В проверяемых св-вах участвуют id процессов

# Факты и приемы
## TLA+ (как язык)
### Моделирование обмена сообщениями
-------------------------------------
#### Raft
Явно моделируем отправку сообщений. Для этого поддреживаем [все сообщения](https://github.com/ongardie/raft.tla/blob/34cdd49d22615426ea00a6605b95be57b3cab49a/raft.tla#L32)
В сообщение указывается Term в котором оно было отправлено и при получении смотрим, что оно меньше текущего.

#### Paxos
Есть [set](https://github.com/fpaxos/fpaxos-tlaplus/blob/c562667ad96bcb9e07a30417a45b49c5d21d1fbe/FPaxos.tla#L25) всех сообщений. Сет описывает все сообщения, которые сейчас есть в нашей системе(проводах и т.п.).  
Для отсылки сообщения происходит просто добавление его в set. Мы явно [задаем](https://github.com/fpaxos/fpaxos-tlaplus/blob/c562667ad96bcb9e07a30417a45b49c5d21d1fbe/FPaxos.tla#L13) типы сообщений, которыми могут обмениваться ноды.
Сет делает доставку сообщение до нод асинхронной(?), как в настоящей системе.
Можно заметить, что в спеке в фазе Prepare у сообщений [нет адресата](https://github.com/fpaxos/fpaxos-tlaplus/blob/c562667ad96bcb9e07a30417a45b49c5d21d1fbe/FPaxos.tla#L37) так мы посылаем сообщением всем асепторам разом.
А в фазе Accept у сообщения уже есть адресат. Надо для того, чтобы понимать, что acceptor находится в кворуме текущем.

#### Kafka
Нет моделирования явной отправки сообщений. Есть shared memory(зукипер).

### Моделирование сети
---------------------------------------
#### Raft
[Моделируем](https://github.com/ongardie/raft.tla/blob/34cdd49d22615426ea00a6605b95be57b3cab49a/raft.tla#L438) сбои сети
Для этого сделаны 2 экшена, которые могут дублировать сообщения или дропать их.

### Честность
В TLA+ есть два вида честности: SF и WF.
_SF_ -
_WF_ -
Применение можно найти в [Kafka](https://github.com/hachikuji/kafka-specification/blob/3cc3cf6914f76573f8b66fb700f8b90ac7ca8bed/KafkaTruncateToHighWatermark.tla#L44)
WF стоит у события выбора лидера. В спеке кафки может быть так, что лидер не будет выбран долгое время. И наша система не будет совершать прогресс.
Чтобы избежать такого "тупого" поведения, нам хочется "повысить приоритет" у действия `BecomeLeader`.
Аналогично происходит с SF. Добавляя честность мы отдаем приоритет некоторым действиям и запрещаем нашему алгоритму некоторые ненужные траектории.

### Редукция и симметрия

## Алгоритмы

### Выборы лидера
----------------------------------------
#### Kafka


#### Raft

### Тестирование

### Сбои
Почему нет "я мертв"?
Сбои не моделируютя явно, так как мы не различаем мертвый узел и узел, который долго не отвечает

### Уточнение спеки

### Как сделать читаемым Trace
Надо писать Next в виде простой дизъюнкции ([пример](https://github.com/hachikuji/kafka-specification/blob/3cc3cf6914f76573f8b66fb700f8b90ac7ca8bed/KafkaTruncateToHighWatermark.tla#L33)).
