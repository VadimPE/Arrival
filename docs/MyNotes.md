# Как начать
* Решить, какие св-ва мы хотим проверять.
* Выделить основных действующих лиц. Например: реплики, или прроцессы, или вообще транзакции. Надо понять, что мы хотим моделировать.
* Выделить состояния, в которых может находится система. Какие действия над ней могут совершать
* Понять уровень детализации. Например, в системе происходит общение реплик через ZooKeeper, тогда мы можем воспринимать ноду в зукипере - как ячейку разделяемой памятии и не моделировать "кишки" самого ЗК.
* Основные методы взаимодействия (Обмен сообщениями или взаиможейтсвие через разделяемую память)
* Выделить глобальные объекты, которые у нас будут играть ключевую роль в алгоритме (сет с сообщениями, реплики, лог и т.д.)
* Если мы хотим просто проверять какие-то св-ва, то, возможно, надо будет сделать tuple для истории
* Вероятно, для того, чтобы не рассматривать бесконечное поведение, стоит сразу сделать с CONSTANT set с уникальными id, для сообщений. (Например, в спеке про CH я ограничиваю длину лога просто делая сет с уникальными id для каждого сообщения)
* Дальше я бы приступил к написанию TypeOK для вашей спеки. Так как это сразу сделает один из invarinats, которые надо проверять, а так же это поможет потом отлавливать тупые баги, который вы могли бы допустить
* Для каждого из объектов, которые вы добавили в VARIABLES надо описать все возможные значения, которые он будет принимать
*

# Мои мысли
## ПРоверка на линеаризуемость для КХ
* В КХ нет sync между нодами в ЗК, поэтому мы можем получить историю, которая не удовлетворяет seq-cons
* Получим историю, которую чекер считает не линеариз. и проверим ее через спеку о линеаризуемости
* История будет выглядеть так:
    H = <<type -> Insert, value x, proc -> A;
          type -> OK, proc -> A;
          type -> Insert, value y, proc -> A;
          type -> Read,  proc -> B;
          type -> OK, value x, proc -> B;
          type -> OK, proc -> A;
          type -> Read, proc -> B;
          type -> OK, value y, proc -> B;
          type -> Read, proc -> B;
          type -> OK, value x, proc -> B;>>

# Заметки о статьях
[Teaching Rigorous Distributed Systems With Efficient Model Checking](https://ellismichael.com/papers/dslabs-eurosys19.pdf)
* Новые подходы к проверке(удаление нерелевантных состояний и поиск промежуточных состояний, прежде чем уходить вглубь)
* Поверх кода клиента пишется обработчик событий, который команды отправляет клиенту
* Предполагаем asynchronous net model
* Предполагаем, что ноды могуть падать (не Визайнтийские отказы)
* Однопоточный цикл событий
* Граф состояний похож на TLA (вершина - состояние всех узлов, переход - доставка какого-то сообщения)
* Граф не зависит от порядка событий, а зависит от состояния системы. Граф явно не строим
* Видимо, не проверяют liveness
* Поиск в ширину на графе состояний (Есть set пройденных состояний и очередь из новых) (наивное решение)
* Пытаются убирать недетерминизм с помощью клонирования состояний и проверки их на равенство (поддерживают рандомный таймер)
* Часто граф состояний бесконечени и число состояний на n шагов ~exp(n).
* Pairing Progress with Safety: ищем сначла состояние прогресса на глубине, а потом пытаемся найти ошибку (Мнение, что если совершил прогресс за n шагов, то и ошибку вероятно можем совершить за n шагов)
* Guiding the Search: хотим показать места, где не могут быть потенциальные ошибки с помощью prunes — predicates (Удалим состояния, где они выполняются). Итеративный подход к проверке. Ищем промежуточное состояние, а потом начинаем делать поиск из него (говорим состояние, которые наиболее интересны).
