# Часть 3 (TLA+)
В предыдущий главе мы научились моделировать распределенные системы с помощью TLA+.

В этой главе мы поговорим про верификацию модели с помощью TLC.

## Model Checker

Формальное описание системы переводится в граф конфигураций.

Граф конфигураций описывает все возможные выполнения нашей системы.

Model checker обходит этот граф, используя BFS, и в каждом состоянии проверяет заданные свойства.

## Масштаб модели
Для верификации построенной модели в ней нужно зафиксировать значения параметров, отвечающих конкурентной активности: число реплик в распределенной системе, число proposal-ов в Single-Decree Paxos, число транзакций в Percolator и т.д.

Эти параметры ограничивают число состояний модели и делают ее пригодной для model checking-а.

Нетрудно заметить, что число состояний в конкурентной системе будет экспоненциально зависеть от значений этих параметров. А значит мы не сможем позволить себе тот же масштаб, что и в реальной системе.

Время работы BFS линейно от количества вершин в графе, а значит оно тоже будет экспонециально от количества параметров системы, что при увеличении значений будет экспонециально увеличивать время на верификацию.

Из-за этого мы хотим уменьшить кол-во состояний системы и проверить наши свойства.

Поэтому разумно с помощью TLC проверять только небольшие модели в которых число участников/действий небольшое число. Например: proposal-ов в Basic Paxos, транзакций в Percolator, аппендов в Kafka измеряется единицами (3-5), в то время как в реалной системе их на многие порядки больше, так как число состояний = exp от параметров системы.

Тем не менее, model checking даже для небольших значений параметров все же может убежать в корректности. Природа конкурентных багов такова, что они хоть и требуют большого числа шагов, но как правило моделируются на небольшом числе узлов / потоков / транзакций. Поэтому можно ожидать, что если существует исполнение, которое нарушает свойства, то оно будет представлена даже в модели с небольшим числом узлов / потоков.

Примеры:
* Контрпример для Basic Paxos: аксепта одного значения на большинстве узлов недостаточно для понятия выбора - достаточно 4 proposal-ов
* Баги в lf алгоритмах чаще всего можно промоделировать на очень небольшом числе потоков, независимо от сложности самого бага.
* Read-only аномалия в алгоритме Snapshot Isolation достигается на 3-х транзакциях и 2-х ключах.

В статье "https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-yuan.pdf" аторы изучили 198 сбоев в 5-ти распределенных системах: Cassandra, HBase, Hadoop Distributed File System (HDFS), Hadoop MapReduce и Redis. Они заметили: "Almost all (98%) of the failures are guaranteed to manifest on no more than 3 nodes. 84% will manifest on no more than 2 nodes…. It is not necessary to have a large cluster to test for and reproduce failures."

На практике для верификации распределенных алгоритмов обходятся < 10, единицами реплик / proposal-ов / транзакций.

## Исследование графа
В обычном TLC использует явную проверку моделей: исследует весь граф состояний системы с помощью обхода в ширину. Для проверки инвариантов во время обхода каждое состояние проверяется на удовлетворение написанным свойствам. Иногда не надо полностью исследовать граф састояний, а достаточно найти какое-то интересное поведение.

Приемущества испольщования BFS для явной проверки графа:

Если model checker найдет ошибку, то он вывдат контрпример минмальной длины

Пример: В презентации (http://tla2012.loria.fr/contributed/newcombe-slides.pdf о применении формальных методов инженеры Amazon замечают, что TLC смог найти пример для Read-only аномалии в алгоритме изоляции транзакций SI короче, чем в оригинальной статье про эту аномалию.

Обход графа состояний в ширину позволяет проверять модели с бесконечным числом состояний: все возможные траектории будут исследованы "параллельно", с ростом числа шагов.

Значит чем дольше  model checker исследует нашу спеку, тем больше можно быть увереным, что все хорошо.

Но если мы знаем, что у алгоритма нет короткого контрпримера, который нарушает инварианты или хотим проверить, что спека вообще хоть сколько-нибудь рабочая, то удобней будет использовать не BFS, а Simulation mode. Так как в BFS TLC сначала проверяет все короткие поведения, а потом уже более длинные, а в simulation mode model checker выбирает произвольную траектория и исследует ее.

Однако, этот метод подходит для поиска частых траекторий. Так как он использует элемент случайности.

Например, этот способ можно использовать чтобы проверить, что история в SI содержит ReadOnlyAnomaly, а значит не является сериализуемой.

## Дедлоки
Чтобы ограничить число состояний в модели для исследуемой системы, мы ограничиваем число клиентских операций / транзакций, а значит в модели возникают состояния, в которой все события уже произошли и никаких переходов сделать уже нельзя.

TLC по умолчанию примет эти состояния за дедлок алгоритма, хотя они говорят лишь о конце работы системы.

Если запустить TLC, то он найдет это состояние, из которого нет перехода в другие, в терминах TLC - это дедлок.

Чтобы избежать “ложных” срабатываний, заведем дополнительный дизъюнкт в Next, который будет порождать явную петлю в состояниях, в которых исчерпаны ограниченные нами внешние события: клиентские запросы / транзакциии / proposal-ы, таким образом мы избавимся от технического дедлока.

Пример в [SI]:

    LegitimateTermination ==  FinalizedTxns(history) = TxnId

## Уменьшение состояний
В модели надо указать значение всех констант в системе.

Иногда константе можно дать какое-то определенное значение, но иногда требуется, чтобы это значение было уникальным и не равнялось ничему другому.

Например:

В Kafak или SI у нас есть набор участников системы. Мы могли бы сделать каждую реплику числом, но TLA+ позваляет дать уникальный индентификатор, который нигде больше не встретиться. Для этого используется model value

Мы можем заменить replicas <- {1, 2, 3} => replicas <- [model value]{r1, r2, r3}.

Если где-то в спеке будет написано что-то сложнее чем сравнение с этим значением, то TLC сообщит об этом.

Обычно такое требуется для названия узлов системы, или когда надо сделать константу NONE.

Когда одна из CONSTANT является множеством, то часто перестановка элементов в этом множестве не нарушит инварианты системы.

Это может помочь TLC уменьшить количество достижимых состояний, так как теперь состояния, которые различаются только порядком элементов этого сета будут считаться одинаковыми.

Для того, чтобы сделать это в IDE в разделе "Model Overview" в поле "What is the model" надо явно указать, что множество является symmetric.

Наборы симетрии не могут использоваться, когда мы хотим проверять liveness свойства. Так как теперь мы не рассматриваем все состояния системы и могли удалить те из них, где liveness св-во нарушается или наоборот выполняется.

Еще одним из способов уменьшения количества состояний системы является отправка сообщений без указания явного адресата. Мы просто прячем все варианты point-2-point общения в один элемент множества.

Аналогично мы умешьнаем кол-во состояний, когда для дедубликации сообщений явно не удаляем их из множества.

Вместо этого мы могли бы после обработки сообщения удалять его из всех собщений сети и добавить экшен, которые бы в произвольные моменты времени мог явно моделировать дубликаты сообщений, что породило бы больше состояний системы. Так как множество сообщений может произвольно изменяться.

Так же уменьшить количество состояний можно не моделируя объект, которые не играет роли в проверке свойства.

Например:

В спеке SI можно явно не моделировать DataStore, так как на свойства сериализуемости влияют только команды и ячейки, к которым они были применены в транзакции. А это можно хранить прямо в истории действий транзакции.

    ReadOnlyAnomalyTest == <<
        [type |-> "begin",  txnId |-> 0, time |-> 0],
        [type |-> "write",  txnId |-> 0, key |-> "K_X", val |-> 0],
        [type |-> "write",  txnId |-> 0, key |-> "K_Y", val |-> 0],
        [type |-> "commit", txnId |-> 0, time |-> 1, updatedKeys |-> {"K_X", "K_Y"}]
        ...

## Тестирование
Хотя спецификация системы в TLA+ и является логической формулой, к ней все применимы критерии качества и техники работы с программным кодом. Если спека достаточно велика (как, например, Snapshot Isolation), то эти техники становятся жизненно необходимыми.
* единый стиль кода
* писать комментарии для сложных экшенов
* проверять покрытие "кода" спеки и корректность отдельных операторов


### Юнит-тестирование
Полезно писать юнит-тесты для отдельных нетривиальных операторов из которых потом строятся свойства.

Пример:

Например, в спеке SI юнит тесты проверяют, что оператор FindAllNodesInAnyCycle обнаруживает цикл в графе конфликтующих транзакций. Этот оператор используется для тестирование свойства сериализуемости, которое описывает, как упорядочиваются конкурирующие транзакции.

    UnitTests_FindAllNodesInAnyCycle ==
        /\ FindAllNodesInAnyCycle({})                                                       = {}
        /\ FindAllNodesInAnyCycle({<<"a", "b">>})                                           = {}
        /\ FindAllNodesInAnyCycle({<<"a", "b">>, <<"b", "c">>, <<"c", "d">>})               = {}
        ...

Следующие тесты проверяют, что спецификация пораждает валидные истории исполнения транзакций: каждая транзакция в истории проходит через шаги Begin -> [Write|Read] -> Abort|Commit.


    UnitTest_WellFormedTransactionsInHistory ==
             (* must begin *)
        /\   WellFormedTransactionsInHistory(<<[op |-> "begin", txnid |-> "T_1"]>>)
        /\ ~ WellFormedTransactionsInHistory(<<[op |-> "write", txnid |-> "T_1", key |-> "K_X"], [op |-> "begin", txnid |-> "T_1"]>>)
             (* multiple begin *)
        /\ ~ WellFormedTransactionsInHistory(<<[op |-> "begin", txnid |-> "T_1"], [op |-> "begin", txnid |-> "T_1"], [op |-> "write", txnid |-> "T_1", key |-> "K_X"]>>)
        ...

"Запустить" тесты можно так:
 1) В секции TLC "What is the behavior spec?", выбрать "No Behavior Spec"
 2) В "Evaluate Constant Expression" написать название юнит-теста

### Покрытие кода
Если TLC не нашел нарушения свойств, то полезно убедиться, что он при этом действительно исследовал нетривиальные поведения системы и использовал все описанные экшены.

Иначе говоря, полезно проверить покрытие "кода" спеки.

Например:
* В SI можно проверить, что транзакции вообще начинаются и некоторые выполняются. Так как только тогда можно говорить о каких-нибкдь свойствах
* В Paxos можно проверить, что вторая фаза алгоритма вообще происходит.

Для того, чтобы проверить наличие нетривиальной траектории, нужно написать инвариант, который будет выделять его, и проверить его отрицание.

Если model checker сообщит о нарушении инварианта, то можно гарантировать, что TLC проверяет нетривиальные трактории.

Пример:

В спеке SI автор ищет поведения, которые удовлетворяют ReadOnlyAnomaly, а значит, что алгоритм пораждает несериализуемые расписания.

    ReadOnlyAnomaly(h) ==
            (* current history is not serializable *)
        /\  ~ CahillSerializable(h)
            (* and there is a transaction that does some reads and zero writes,
               and when that transaction is entirely removed from the history,
                   the resulting history is serializable. *)
        /\ \E txn \in TxnId :
                LET keysReadWritten == KeysReadAndWrittenByTxn(h, txn)
                IN
                    /\ Cardinality(keysReadWritten[1]) > 0
                    /\ Cardinality(keysReadWritten[2]) = 0
                    /\ CahillSerializable(HistoryWithoutTxn(h, txn))

В спеке про репликацию в КХ можно проверить, что мерджи назначаются. Для этого будем проверять, что в любом поведении нет мерджей

    DoNotMerge == [](\A record \in Range(log): record.type != "Merge")

Разработчик TLC работает на встроенным профилированием в IDE, чтобы не писать такие инварианты самому.

### Мутационоое тестирование
Мутационное тестирование  — это метод тестирования системы, при котором в программу небольшие деструктивные изменения, которые должны сломать тесты. Если этого не произошло, то тесты надо переделать.

В спеке поменять произовльную часть программы не получится. Вместо этого изменения вносятся в важные фрагменты спеки.

Вместо покрасневших тестов мы ожидаем, что TLC обнаружит нарушение свойств.

Например: в спеке FPaxos можно изменить системы кворумов. На второй фазе MCQuorum2 == {{a1, a3},{a2, a4}} -> {{a1},{a2, a4}}. После этого надо запустить провреку и увидим, что у нас нарушилось св-во *SafeValue*, так как алгоритм Паксоса построен на том, что кворум из первый фазы точно пересечется с кворумом из второй фазы хотя бы по одному acceptor-у, и тем самым будет обнаружено ранее предложенное значение. (для работы надо удалить ASSUME). А мы убрали этот инвариант и алгоритм смог принять 2 значения.

Подобные ограничения в TLA формулируют в виде assumption.

Например:
FPaxos

    ASSUME QuorumAssumption == /\ \A Q \in Quorum1 : Q \subseteq Acceptor
                            /\ \A Q \in Quorum2 : Q \subseteq Acceptor
                            /\ \A Q1 \in Quorum1 : \A Q2 \in Quorum2 : Q1 \cap Q2 # {}

Kafka

    ASSUME
        /\ None \notin Replicas
        /\ MaxLeaderEpoch \in Nat

### TypeOk
TLA похож на динамический язык, а значит, он наследует все его проблемы. Например, можно несколько дней ждать пока model checker верифицирует спеку и получить исключение об ошибке конвертации bool к int.

"If a specification language is to be general, it must be expressive. No simple type system is as expressive as untyped set theory. While a simple type system can allow many specifications to be written easily, it will make some impossible to write and others more complicated than they would be in set theory."

Полезно ввести технический инвариант, который будет проверять не свойства системы, а корректность модели – что значения переменных, которые образуют состояния системы, принимают значения определенного типа, который мы используем в реализации.

Как правило в TypeOk описан сетевой протокол, то есть все возможные сообщения, которыми могут обмениваться ноды.

Примеры:

Paxos:

    Message ==      [type : {"1a"}, bal : Ballot]
               \cup [type : {"1b"}, acc : Acceptor, bal : Ballot,
                     mbal : Ballot \cup {-1}, mval : Value \cup {None}]
               \cup [type : {"2a"}, bal : Ballot, val : Value]
               \cup [type : {"2b"}, acc : Acceptor, bal : Ballot, val : Value]

    TypeOK == /\ maxBal \in [Acceptor -> Ballot \cup {-1}]
              /\ maxVBal \in [Acceptor -> Ballot \cup {-1}]
              /\ maxVal \in [Acceptor -> Value \cup {None}]
              /\ msgs \subseteq Message

## Читаемая траектория
TLC умеет печатать трейс, который привел к ошибке. В нем идет перечесление всех VARIABLES, которые есть в системе. Но не всегда понятно, какому экшену соответсвует строчка.

Например:

    Next == \/ \E b \in Ballot : \/ Phase1a(b)
                                 \/ \E v \in Value : Phase2a(b, v)
            \/ \E a \in Acceptor : Phase1b(a) \/ Phase2b(a)

Для читаемости трейса Next представляется в виде простой дизъюнкции всех экшенов

Пример: Kafka

    Next ==
        \/ ControllerElectLeader
        \/ ControllerShrinkIsr
        \/ BecomeLeader
        \/ LeaderExpandIsr
        \/ LeaderShrinkIsr
        \/ LeaderWrite
        \/ LeaderIncHighWatermark
        \/ BecomeFollowerTruncateToHighWatermark
        \/ FollowerReplicate

При использовании такой записи в трейсе будет явно отражен, какой экшен был взят.

Такой подход требует, что бы мы внесли квантор существования в каждый отдельной экшен, но с другой стороны хочется, чтобы один квантор был для всех действий одной сущности.

Надо сдедать выбор между читаемостью трейса или читаемостью спеки.

## TLC и командная строка
Кроме IDE TLC можно использовать из консоли.

Для того, чтобы использовать model checker из командной строкой надо:
* Установить TLA+.
* Установить bin-файл в вашу систему
* Создать фалй для тестировния MCMyspec.tla: В нем надо задать те параметры, которые вы передадите в CONSTANT для тестирования

Пример:

    CONSTANTS a1, a2, a3, a4  \* acceptors
    CONSTANTS v1, v2      \* Values

    MCAcceptor == {a1, a2, a3, a4}
    MCValue    == {v1, v2}
    MCQuorum1 == {{a1, a2},{a3, a4}}
    MCQuorum2 == {{a1, a3},{a2, a4}}
    MCBallot == 0..1

В нем определили константы для ключей и акцепторов и определили множества, которые использует сама спека)
* Создать конфигурационный файл для спеки. В катором будет оражение параметров из файла для тестирования в параметры спеки.

Пример:

    SPECIFICATION Spec
    CONSTANTS
      a1=a1  a2=a2  a3=a3  a4=a4 v1=v1  v2=v2
      Acceptor <- MCAcceptor
      Value    <- MCValue
      Quorum1   <- MCQuorum1
      Quorum2   <- MCQuorum2
      Ballot   <- MCBallot
      None     =  None

    INVARIANT SafeValue TypeOK

Нас интересуют больше всего параметры: INVARIANTS (инварианты системы), PROPERTIES (liveness св-ва), CONSTANTS (отображение параметров), SPEC (сама спека)
* Чтобы запустить тестирование надо выполнть команду tlc MCMyspec.tla

Удобство от такого испольщования в том, что IDE генерирует файл для model checker-а в нечитаемом виде. Открыть его просто так и разобраться в нем - очень сложно. Для того, чтобы вашу спеку могли запустить с нужными параметрами, надо отдельно описывать настройки. А файл для командного tlc понятен и находится рядом со спекой
