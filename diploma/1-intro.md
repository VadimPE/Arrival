# Часть 1 (Intro)
## Стандартные подходы к тестированию
Распределенные системы - это ключевой компонент систем хранения и обработки данных и современных масштабируемых сервисов.

Например:
* Kafka используется в Linkedin, The New York Times
* Snapshot Isolation (Percolator) используется в Gmail, Calendar у Google

Написать корректный код для такого рода систем намного сложнее, так как надо учитывать мн-во факторов, которые могут влиять на алгоритм (потеря сообщений, отказ узлов и т.д.). Из-за этого одной из главных проблем для таких сервисов является тестирование.

В индустрии используются несколько стандартных техник для верификации (проверка соответствия системы набору требований: например, если система подтвердила запись данных, то она не может их потерять) систем:
* Стандартное тестирование - разработчики пишут мн-во тестов, которые новый код должен пройти, прежде чем его добавят в кодовую базу. Этот метод не подходит для распределенных систем, так как мн-во факторов из внешнего мира может влиять на систему, а моделировать это с помощью стандартных тестов невозможно.
* Код ревью - после прохождения всех рукописных тестов разработчики пытаются найти баги с помощью просмотра нового кода. Это слишком дорого и требует больших затрат.

Вот, что пишут инженеры из Amazon о стандартных методах тестирования систем: "We use deep design reviews, code reviews, static code analysis, stress testing, fault-injection testing, and many other techniques, but we still find that subtle bugs can hide in complex concurrent fault-tolerant systems. One reason for this problem is that human intuition is poor at estimating the true probability of supposedly ‘extremely rare’ combinations of events in systems operating at a scale of millions of requests per second ... We have found that testing the code is inadequate as a method to find subtle errors in design, as the number of reachable states of the code is astronomical. So we looked for a better approach."

## model checker/ TLA+
В противопоставление этим методам ученые придумали способ тестирования - model checking. Язык формальной верификации - это формальная система, которая фокусируется на том, что должна делать программа, а не как (в отличие от языков программирования).

Система/алгоритм описывается математическим языком и model checker исследует все возможные выполнения смистемы и проверяет св-ва.

Одной из самых популярных реализаций такого подхода является язык TLA+ и model checker для него.

TLA+ - это язык формальной спецификации, который основан на нетипизированная теории мн-в, логике первого порядка и TLA. TLA - это темпоральная логика, с помощью которой можно описать распределенные и многопоточные системы/алгоритмы.

Основные понятия, которыми оперирует TLA+:
* Автомат (State Machine) – некоторое состояние, которое описывается набором переменных
* Состояние автомата / системы - назначение значений этим переменным
* Поведение / траектория – бесконечная последовательность состояний
* Свойства – формулы LTL, которые интерпретируются на траекториях, т.е. последовательностях состояний
* Спецификация – декларативное описание поведения системы (состояний и переходов)


Типичная спецификация на TLA+ выглядит как: Spec == Init /\ []Next /\ Liveness
* Init - initial-state predicate. Формула, которая верна для всех начальных состояний
* Next - отношение следующего состояния. Является дизъюнкцией нескольких действий и описывает все возможные следующие действия
* Liveness - формула, которая определяет liveness (прогресса) св-ва нашей системы. Нужно заметить, что этот тип св-в обычно не применяется для распределенных систем.

В TLA+ рассматриваются траектории с бесконечным кол-вом состояний, это хорошо подходит для описания распределенных систем, из-за св-ва реактивности узлов (нет никаких гарантий по времени реакции узла на событие).

TLA+ использует LTL - это язык линейного времени. Он хорошо подходит, так как св-ва в нем описывают какое-то выполнение системы, так как описывать св-во для нескольких исполнений сразу не имеет смысла.

Примеры:
* Св-во, что в [SI](https://github.com/pron/amazon-snapshot-spec/blob/9c60cb18151889d7b4c0a4ffd7de0b6fc2db0fb2/textbookSnapshotIsolation.tla#L876) побеждает та из конкурирующих транзакций, которые работают с одной ячейкой памяти, которая первая закомититься.
* Св-во в [Paxos](https://github.com/fpaxos/fpaxos-tlaplus/blob/c562667ad96bcb9e07a30417a45b49c5d21d1fbe/FPaxos.tla#L89), что для любого выполнения будет принято ровно одно значение.

Как TLA+ применяется к распределенным системам:
* Вершины в графе состояний - это глобальные состояния всех узлов, состояние сети
* Ребра в графе - это реакция узлов на события системы.
* Таким образом TLC исследует граф конфигураций системы и проверяет его на выполнение св-вам.

Инженеры Amazon Web Services поделились своим опытом применения формальных методов в статье “Use of Formal Methods at Amazon Web Services”. Они примени TLA+ к нескольким критически важным для облачной инфраструктуры алгоритмам: сетевые протоколы, протоколы репликации и переконфигурации, лок-фри алгоритмы.

![result](res.png)

Этот метод тестирования помог отловить сложные баги в критически важных инфраструктурных компонентах. Например, найден баг в DynamoDB, который требует 35 шагов алгоритма. Так же одним из важных аспектов использования TLA+ является то, что он помогает получить правильный дизайн системы. Если в дизайне системы допущена ошибка, то и в коде она тоже будет допущена. Так же формальное описание системы помогает лучше понять алгоритм, который реализован.

## ClickHouse
ClickHouse - столбцовая система управления базами данных (СУБД) для онлайн обработки аналитических запросов (OLAP)
0) Модель данных КХ оперирует таблицами. Каждая таблица реализуется определенным движком, который отвечает за механизм хранения данных и процесс обработки клиентских запросов
1) КХ поддерживает горизонтальное масштабирование с помощью распределенных шардированных таблиц, которые реализуются движком "Distributed"
2) КХ - отказоустойчивая система, где каждый шард распределенной таблицы независимо реплицируется, протокол репликации инкапсулирован в семействе движков "Replicated"
3) Сама репликация устроена с помощью отказоустойчивого лога, который выполняют реплики. Лог хранится в ZooKeeper-е. В логе присутствует информация о вставках, мерджах и т.д. Сами данные в записях лога не хранятся. Их реплики получают с помощью взаимодействия по http.

Основная задача состоит в формальном описании алгоритма репликации КХ и в проверке правильности алгоритмов для обрезки лога в ZooKeeper и для кворумных вставок и чтений в КХ.

## План работы
В главе 1 будут описаны принципы спецификации распределенных систем с помощью TLA+:
* Как выбрать нужный уровень детализации для системы/алгоритма
* Надо ли моделировать сбои в спеках
* Как моделировать сеть в алгоритмах, где используется взаимодействие через отправку сообщений между узлами
* Каким образом TLA+ позволяет описать недетерминизм, который возникает в системе.

В главе 2 пойдет речь об инженерных аспектах формальной верификации:
* Как протестировать саму спецификацию
* Как сократить число состояний в графе конфигураций
* Какие есть режимы у model checker

Для ответов на эти вопросы мы будем использовать существующие спецификации для распределенных систем/алгоритмов:
* Kafka - протокол репликации партиции в распределенной персистентной очереди сообщений
* Snapshot Isolation - алгоритм изоляции транзакций, работающий поверх мультиверсионного хранилища данных
* Percolator - аналогичный алгоритм изоляции транзакций поверх BigTable.
* Paxos - протокол консенсуса в модели передачи сообщений.
* Raft - также протокол консенсуса

В главе 3 мы применим все разработанные приему для формальной спецификации и верификации протокола репликации в распределенной аналитической базе данных ClickHouse.
