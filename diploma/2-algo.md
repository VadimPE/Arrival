# Часть 2 (Алгоритмы)
## Уровни абстракции
Система или алгоритм, который мы хотим написать может состоять из нескольких частей. Пользователь со стороны наблюдает нашу систему как единое целое. Он приходит на "контур", который дальше отправляет его запрос на какую-то ноду. Наша система может использовать сторонние сервисы, например, одной из частей системы может быть ZooKeeper или может представлять из себя набор нод, которые обмениваются сообщениями между собой. Нам надо уметь понимать, что мы хотим описывать в спеке, а что нет. Для начала надо выделить основных участников системе. Ими могут быть ноды (Паксос, Raft) или сущности, над которыми происходит воздействие(транзакции в SI). То есть мы можем описать нашу систему со стороны участников, которые производят действия или со стороны объектов, над которыми эти действия выполняются. Сравним существующие системы и их спеки:
* Paxos/Raft: В этих алгоритмах основными участниками являются ноды. Мы хотим описать алгоритм общения между ними, моделируя передачу сообщений, сеть и т.д. Это самый высокий уровень детализации. Мы хотим полностью описать, как ведут себя участники алгоритма, их протокол взаимодействия и проблемы, с которыми они сталкиваются. В системах, где одной из составляющих является обмен сообщениями по сети надо уметь моделировать асинхронность сети.
* Kafka: Участники репликации в Kafke используют  ZooKeeper. Мы не хотим моделировать, что происходит внутри ZooKeeper, так как полагаем, что эта система работает и надежна. "This is the model's equivalent of the state in Zookeeper, but generally we ignore the complexity of Zookeeper itself. Instead we allow simple atomic operation to the state directly within individual actions" Единственное место, где мы хотим описать взаимодействие реплик - это обмен сообщениями о leader election. Нода в ZK - это распределенная отказоустойчивая ячейка памяти, которую изменяют наши реплики в экшенах. Так же есть сущность, которая называется контроллер, он отвечает за выборы лидера.
* ClickHouse: Система использует ZooKeeper для всех распределенных алгоритмов: Выборы лидера, репликация и др. Обмен сообщениями между репликами происходит только по отправке данных в репликации. Будем считать, что система получила кусок данных тогда, когда обработало информацию о вставке в ZK. Это самый высокий уровень абстракции, так как мы моделируем систему только такой, как ее видит пользователь. Мы абстрагируемся от обмена сообщениями.

## Моделирование сети и отправки сообщений
При моделировании обмена сообщениями в нашей системе появляется еще один важный участник - это сама сеть. Сеть может породить проблемы при передаче сообщений между нодами (дубликацию, пропажу и т.д.). Так как система асинхронная, то мы не можем сказать, когда сообщения будут доставлены и в каком порядке.

* Первым делом мы хотим промоделировать все сообщения, которые есть в нашей системе.(находятся в "проводах" или доставляются до ноды). Для асинхронности в TLA есть тип данных - set, он помогает обеспечить недетерминизм в системе. Конструкция \E val \in set: P(val). Выдает рандомный элемент нашего сета, который удовлетворяет предикату. Тем самым порядок на получение элемента не гарантирован. Следовательно, это помогает моделировать reordering на отправленных сообщениях и их задержку. Например, в [Raft-е](https://github.com/ongardie/raft.tla/blob/34cdd49d22615426ea00a6605b95be57b3cab49a/raft.tla#L306) при получении сообщения проверяется в каком term-е оно было отправлено, чтобы не обрабатывать сообщения из прошлого.
* Нам надо уметь моделировать отправку сообщений участникам системы. Промоделировать отправку кому-то одному - очень легко. Например, в [Raft-e](https://github.com/ongardie/raft.tla/blob/34cdd49d22615426ea00a6605b95be57b3cab49a/raft.tla#L306) явно указывается кому и от кого пришло сообщения. Так же надо уметь промоделировать отправку сообщений всем участникам. Например в Paxos у сообщений в фазе 1а и 2а нет явных адресатов. Таким образом, [нода отправляет](https://github.com/fpaxos/fpaxos-tlaplus/blob/c562667ad96bcb9e07a30417a45b49c5d21d1fbe/FPaxos.tla#L25) сообщение всем остальным.
* Логика отправки сообщения может быть простой (мы просто добавляем сообщение в set, таким образом set только увеличивается и никогда не уменьшается или наши сообщения после обработки могут удаляться из set. Когда мы только увеличиваем сет, то сообщения могут обрабатываться повторно, так как оператор  \E не гарантирует никакой порядок с котором сообщения будут взяты и будут ли вообще. Поэтому, когда мы изменяем сет с сообщениями сами, нам надо уметь моделировать проблемы, которые может производить сеть. Если мы после удаляем обработанные сообщения из сета, то мы отказываемся от дедубликации и потери сообщений. Нам надо самим добавить экшены, которые будут моделировать такие ситуации. Так сделали в [Raft](https://github.com/ongardie/raft.tla/blob/34cdd49d22615426ea00a6605b95be57b3cab49a/raft.tla#L438)

## Сбои
Так как систему в спеке описывают как можно ближе к реальности надо уметь описывать проблемы, которые могут происходить. Большинство распределенных алгоритмов и систем содержит несколько нод, сервера не могут жить вечно, могут долго не отвечать и т.д. В асинхронной системе у нас нет возможности отличить умершую ноду и ту, которая долго обрабатывает наш запрос. В связи с этим, возникает вопрос: Надо ли нам моделировать падение сервера в нашей спеке?

Первым делом надо понять, что такое умершая нода в рамках графа конфигураций.
Мы описываем состояния, в которых наша система может прибывать, и переходы между ними. TLC строит граф конфигураций поверх наших экшенов и исследует его. Получается граф, где вершины - это состояние нашей системы, а ребра - это переходы между ними (доставка сообщения или срабатывания таймаута). Выполнение нашей системы - это путь в этом автомате из стартовой конфигурации в конечную (Иногда конечной конфигурации может не быть, то есть состояний системы б.м., но от этого стараются отойти, чтобы проверять св-ва). Аналогичную конструкцию используют в док-ве FLP *Ссылка*. Авторы FLP пишут, что они не различают умершую ноду от той, которая долго не отвечает. В рамках графа конфигураций в пути просто не будет переходов, связанных с умершей нодой. Авторы так же замечают, что невозможно в асинхронной сети отличать умершую ноду от той, которая долго не отвечает.

Что же такое отказ ноды в рамках графа конфигураций TLC? У нас есть экшены, где мы принимаем действие в зависимости от состояний участников, например, какая-то из нод обрабатывает очередное событие и меняет свое состояние, так как TLC исследует все возможные траектории в нашем графе, то чекер проверит траектории все траектории и те, где одна из нод вообще не обрабатывает события, то есть она или долго отвечает, или отказала. Значит, можно считать, что ситуация аналогично схожа FLP и в TLA можно не моделировать сбои узлов, так как TLC их сам промоделирует.

Аналогично TLC моделирует ноды, которые рестартовали после сбоя и опять приняли участие в работе алгоритма. Чекер просто исследует траекторию, где в какой-то момент будет взят экшен, связанные с рестартанувшей нодой.

ПОЧЕМУ НЕ ГОВОРИМ ПРО ВИЗАНТИЙСКИЕ ОТКАЗЫ?

В Raft промоделированы таймауты системы, так как это искусственно созданные события, когда нода должна сбросить свое состояние. TLC не сможет сам промоделировать такое, так как сбои в графе конфигурации - это просто не взятие экшена, а не изменение системы внутренних св-в системы.

## Concurrency, недетерминизм
С первого взгляда может показаться, что в спеках нет никакого недедтерминизма и атомарности, так как мы пишем экшены, которые выполняются атомарно и полностью описываем переходы между ними. Откуда в такой системе может взяться многопоточность и недетрминизм?

Про многопоточность
Цитата:
"The idea that the execution of a sequential algorithm can be described as a sequence of states seems to be due to Turing. It is so widely accepted that most engineers are happy to describe sequential algorithms this way… I think the idea that the execution of a concurrent algorithm (or a concurrent system) can also be described by a sequence of states was implicit in the first paper on concurrent algorithms: Dijkstra’s seminal 1965 paper on mutual exclusion. That idea is not widely known, and many engineers need to be shown how to describe concurrent systems in that way. When they learn how to write such descriptions in TLA+, they find them quite useful."

Вся многопоточность находится в операторе Next, который представляет собой \/ нескольких экшенов. Мы можем в нем совместить 2 программы, которые должны исполняться параллельно и добавить к каждому из экшенов честность. Тогда ОС должна будет строить траекторию таким образом, чтобы обе программы совершали прогресс. То есть мы можем написать алгоритм для нескольких процессов. После соединения этих двух спек, и добавления честности мы получим многопоточный алгоритм.


Недетерминизм играет одну из самых важных ролей в TLA+. Хоть мы и задаем переходы между состояниями, но мы явно не указываем ноду, которая приняла сообщение или время, когда это сообщение было доставлено. Мы можем выразить вещи, которые могут произойти с системой на достаточно абстрактном уровне. Детерминизм реализует разные поведения спеки. Чтобы его выразить надо написать формулу, которая верна для нескольких значений переменных (\/ x = 1 \/ x = 2 \/ x = 3) или можем воспользоваться \E для того, реализовать ветвление алгоритма по разным траекториям.
Когда мы в экшене определяем переменные мы, на самом деле, уменьшаем недетерминизм программы. Но мы можем или вообще зафиксировать значение переенной x' = 1 и убрать весь недетерминизм или добавить недетерминизма \E n \in Set: x' = n и т.д.

## Что моделировать
Когда мы пишем распределенную систему нам удобно рассуждать с точки зрения наблюдателя. Мы хотим промоделировать компоненты, которые играют важную роль в нашей системе. То есть мы моделируем клиента, ноду и что-то еще.  Мы хотим описать систему, как ее видит пользователь, так как это даст большую интуитивность. Мы можем промоделировать действия для разных частей системы. Главное, что если мы хотим добиться прогресса со стороны всех отдельных частей, то нам надо добавить WF для действий у каждого из участников.

Так же мы можем промоделировать не участников системы, а описать поведение объектов, с которыми эта система работает. Например мы можем посмотреть на наш сервис изнутри. И описать как компоненты сервиса могут себя вести. Пусть у нас есть лог с записями. Тогда мы можем промоделировать не клиента, который эти записи делает, а сами записи изнутри. То есть мы можем описать, как они в этой системе себя ведут. Такой подход используется в спеке SI. Там моделируется конечное число транзакций, которые поступают в систему. И для них описываются их основные экшены. Начало, конец или аборт. Дальше мы получаем историю всех этих транзакций. То есть мы видим все возможные варианты, как они могли произойти в системе и проверяем эту историю на св-ва.

Вот, что Лампорт пишет об этом:
"Mathematical manipulation of specifications can yield new insight. A producer/consumer system can be written as the conjunction of two formulas, representing the producer and consumer processes. Simple mathematics allows us to rewrite the same specification as the conjunction of n formulas, each representing a single buffer element. We can view the system not only as the composition of a producer and a consumer process, but also as the composition of n buffer-element processes. Processes are not fundamental components of a system, but abstractions that we impose on it. This insight could not have come from writing specifications in a language whose basic component is the process."

Это все сильно завязано на св-ва, которые мы хотим проверять. Нам не интересно моделировать записи в логе, когда мы хотим проверить, например, алгоритм для выбора лидера в системе. Или репликацию между несколькими серверами. Так как со со "стороны записей" нет понимания о репликации. Нам хочется описывать сущности с которыми работает система, когда мы хотим проверить порядок на них, или увидеть как они взаимодействуют между собой.

## Проверка св-в
Говорят, что распределенный алгоритм или система корректна, если она удовлетворяет safety и liveness св-вам. В рамках TLA мы отоджевстляем св-ва алгоритма и св-ва поведения.

Safety св-ва говорит о плохих событиях, которые не должны происходить в нашей системе никогда. Это св-во, которое верно на каждом шаге исполнения. Заметим, что св-во безопасности нарушается поведением, если какой-то конечный префикс нарушает его. (Мы рассматриваем бесконечные поведения нашей системы).

Liveness св-ва говорит о том, что поведение должно сделать в конечном итоге. То есть св-во будет верно с какого-то момента в нашей системе. Стоит заметить, что для последовательных алгоритмов единственное нетривиальное liveness св-во - это то, что алгоритм завершится. Любой правильный конечный префикс можно расширить, добавлением состояний, где св-во выполнено. Если нарушено liveness св-во, то оно будет нарушено на конечном префиксе исполнения.

Одно из основных Safety св-в - это TypeOK.

Для задания этих св-в используется [логика](https://learntla.com/temporal-logic/).
