# Личный опыт
## Читаемый трейс
TLC умеет печатать трейс, который привел к ошибке. В нем идет перечесление всех VARIABLES, которые есть в системе. Но не всегда понятно, какому экшену соответсвует строчка. Для читаемости трейса Next представляется в виде простой дизъюнкции всех экшенов

Пример: Kafka

    Next ==
        \/ ControllerElectLeader
        \/ ControllerShrinkIsr
        \/ BecomeLeader
        \/ LeaderExpandIsr
        \/ LeaderShrinkIsr
        \/ LeaderWrite
        \/ LeaderIncHighWatermark
        \/ BecomeFollowerTruncateToHighWatermark
        \/ FollowerReplicate

При использовании такой записи в трейсе будет явно отражен, какой экшен был взят.

 Но такой способ стоит использовать не всегда.

Во время дебага спеки такая информативность полезна, так как это помогает быстро обнаружить, где произошла ошибка. Для читателя, который хочет с помощью спеки понять, как устроена система, будет удобней смотреть на экшены, которые относятся к определенным сущностям. Мы хотим сделать мэпинг экшена и участника, который может его произвести.

Например: у нас есть реплика, которая умеет читать запись в логе, становиться неактивной или еще что-то. Есть клиент, который умеет делать Insert или Select. Мы делаем экшен для них:

    ReplicaAction == \E replica \in Replicas: Action1(replica) \/ Action2(replica)

    ClientAction == Insert \/ Select

    Next ==
        \/ ReplicaAction
        \/ ClientAction

Важно: если мы сделали экшен, который принимает параметры, то на него уже нельзя навесить честность.

## Читаемость кода
* TLA+ - это язык, основанный на темпоральной логики. Он помогает описать алгоритм на языке математики, которая лучше подходит для формального описания системы. Не надо писать на нем, как будто это низкоуровневый ЯП. Это убивает всю элегантность и основную идею. Надо избегать использования IF THEN ELSE. Скорее всего, если используется эта конструкция, то можно создвть 2 новых экшена, которые обрабатывают 2 разные ситуации из условного оператора. Основные экшены стоит делать максимально простыми, так чтобы пользователь видел главные шаги, которые происходят атомарно.

## TLC и командная строка
Писать код можно в IDE для TLA+, но не всегда удобно это делать.

Существует простой способом, чтобы запустить tlc - это командный интерфейс.

Бинарный файд умеет не только запускать tlc и проверять вашу спеку, но еще и транслировать PlusCal в TLA.

Для того, чтобы пользоваться командной строкой надо:
* Установить TLA+.
* Установить bin-файл в вашу систему
* Создать фалй для тестировния MCMyspec.tla: В нем надо задать те параметры, которые вы передадите в CONSTANT для тестирования

    -------------------------------- MODULE MCFPaxos -------------------------------
    EXTENDS FPaxos, TLC
    -----------------------------------------------------------------------------
    CONSTANTS a1, a2, a3, a4  \* acceptors
    CONSTANTS v1, v2      \* Values

    MCAcceptor == {a1, a2, a3, a4}
    MCValue    == {v1, v2}
    MCQuorum1 == {{a1, a2},{a3, a4}}
    MCQuorum2 == {{a1, a3},{a2, a4}}
    MCBallot == 0..1

В нем определили константы для ключей и акцепторов и определили множества, которые использует сама спека)
* Создать конфигурационный файл для спеки. В катором будет оражение параметров из файла для тестирования в параметры спеки.
Пример

    SPECIFICATION Spec
    CONSTANTS
      a1=a1  a2=a2  a3=a3  a4=a4 v1=v1  v2=v2
      Acceptor <- MCAcceptor
      Value    <- MCValue
      Quorum1   <- MCQuorum1
      Quorum2   <- MCQuorum2
      Ballot   <- MCBallot
      None     =  None

    INVARIANT SafeValue TypeOK

Нас интересуют больше всего параметры: INVARIANTS (инварианты системы), PROPERTIES (liveness св-ва), CONSTANTS (отображение параметров), SPEC (сама спека)
* Чтобы запустить тестирование надо выполнть команду tlc MCMyspec.tla

Удобство от такого испольщования в том, что IDE генерирует файл для model checker-а в нечитаемом виде. Открыть его просто так и разобраться в нем - очень сложно. Для того, чтобы вашу спеку могли запустить с нужными параметрами, надо отдельно описывать настройки. А файл для командного tlc понятен и находится рядом со спекой


## Дебаг спеки
Во время написания спеки возникала необходимость дебжить спеку. Вот какими приемами пользовался я:
* Писал юнитесты. Я проверял каждый из операторов, который позволял работать с историей или был важен для проверки какого-нибудь св-ва.
* При написании какого-то нового экшена (например Truncate в обрезке лога или Merge в репликации) важно проверить, что существуют поведения, в которых этот экшен будет браться. Я пользовался приемом из главы 3 и писал предикат, который будет выполнен на траекториях, где не происходит интересных действий. После запуска model checker сообщал, существуют ли выполнения, которые захватывают нужный экшен.
* Так же удобно будет пользоваться "Error-Trace Exploration" - это поле находится в окошке, которое появляется, когда чекер находит неправильный трэйс. В него можно записать предикат, значения которого вы хотите посмотреть на всем пути исполнения ошибочного трейса. Например, сюда можно записать части экшена, в котором вы сомневаетесь и посмотреть чему они равны в каждом из состояний на неправильном выполнении.
* Еще одинм полезным способом может оказаться отладочный вывод. Можно в любой экшен дописать /\ PrintT(smth) и во время взятия этого экшена чекером в консоль будет писаться значение выражения smth. По моему опыту это полезно для отлаживания проверки определенных св-в.

Пример: [LIN](https://github.com/lorin/tla-linearizability/blob/6a919f81f41ce43c884b87dde0976143b80d35db/LinQueue.tla#L31). Можно выводить состояние очереди на каждом шаге.

Для проверки модели этот способ не так хорош, экшен может браться б.м. раз и по выводу сложно понять, что происходит.
