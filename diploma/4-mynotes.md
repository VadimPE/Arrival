# Непутевые заметки
## Общие советы
* Читаемый трейс: TLC умеет печатать трейс, который привел к ошибке. В нем идет перечесление всех VARIABLES, которые есть в системе. Но не всегда понятно, какому экшену соответсвует строчка. Для читаемости трейса можно Next представить в виде дизъюнкции всех экшенов

Пример: [Kafka](https://github.com/hachikuji/kafka-specification/blob/3cc3cf6914f76573f8b66fb700f8b90ac7ca8bed/KafkaTruncateToHighWatermark.tla#L33)

При использовании такой записи будет понятно в трейсе, какая была история и какие экшены были взяты. Но такой способ стоит использовать не всегда.


Во время дебага спеки такая информативность полезна, так как это помогает быстро обнаружить, где произошла ошибка. Для читателя, который хочет с помощью спеки понять, как устроена система, будет удобней смотреть на экшены, которые относятся к определенным сущностям. Мы хотим сделать мэпинг экшена и участника, который может его произвести.

Например: у нас есть реплика, которая умеет читать запись в логе, становиться неактивной или еще что-то. Есть клиент, который умеет делать Insert или Select. Мы делаем экшен для них:
    1) ReplicaAction == \E replica \in Replicas: Action1(replica) \/ Action2(replica)
    2) ClientAction == Insert \/ Select

Важно: если мы сделали экшен, который принимает параметры, то на него уже нельзя навесить честность.

* TLA+ - это язык, основанный на темпоральной логики. Он помогает описать алгоритм на языке математики, которая лучше подходит для формального описания системы. Не надо писать на нем, как будто это низкоуровневый ЯП. Это убивает всю элегантность и основную идею. Надо избегать использования IF THEN ELSE. Скорее всего, если используется эта конструкция, то можно создвть 2 новых экшена, которые обрабатывают 2 разные ситуации из условного оператора. Основные экшены стоит делать максимально простыми, так чтобы пользователь видел главные шаги, которые происходят "атомарно".

## Как пользоваться TLC из командной строки
IDE для TLA+ еще развивается и иногда не очень удобна. Существует более простое решение - это командный интерфейс для TLC. Бинарник умеет не только запускать tlc и проверять вашу спеку, но еще и транслировать PlusCal в TLA и проводить анализ вашей спеки.
* Установить TLA+ [отсюда](http://lamport.azurewebsites.net/tla/tla.html)
* Установить bin-файл в вашу систему [тут](https://github.com/pmer/tla-bin)
* Создать фалй для тестировния (MCMyspec.tla): В нем надо задать те параметры, которые вы передадите в CONSTANT для тестирования ([пример](https://github.com/fpaxos/fpaxos-tlaplus/blob/master/MCFPaxos.tla) В нем определили константы для ключей и акцепторов и определили мн-ва, которые использует сама спека)
* Создать конфигурационный файл для спеки. [пример](https://github.com/fpaxos/fpaxos-tlaplus/blob/master/MCFPaxos.cfg)
Нас интересуют больше всего параметры: INVARIANTS (те св-ва, которые верны всегда), PROPERTIES (liveness св-ва), CONSTANTS (надо сделдать мапинг из значений в MCMyspec.tla в параметры нашей спеки), SPEC (ваша спека)
* Чтобы запустить тестирование надо выполнть команду tlc MCMyspec.tla

Почему стоит пользоваться таким способом: Когда вы используете IDE, то файл для TLC генерируется автоматически и по нему невозможно понять, что вы проверяете и какие настройки сделали. Чтобы описать, как вы запускали проверку надо выложить или сам файл TLC(который надо открыть в IDE), либо надо где-то отдельно описывать насройки для TLC. В способе же с командной файл с конфигурацией находится рядом со спекой. И человек может без открытия IDE определить, с какими параметрами и св-вами происходила проверка.

## Дебаг спеки
Во время написания спеки возникают ситуации, когда надо понять, что ты пишешь что-то адекватное.
Какими приемами польщовался я:
* Писал юнитесты. Я проверял каждый из операторов, который позволял работать с историей или был важен для проверки какого-нибудь св-ва.
* При написании какого-то нового экшена (например Truncate в обрезке лога или Merge в репликации) важно проверить, что существуют поведения, в которых этот экшен будет браться. Надо написать инвариант, что [](smth), где smth - это описание поведения, где экшен был бы не взят. Ну например, у нас в логе не появятся записей о мердже. Дальше мы должны запустить чекер с проверкой этого инварианта. Если мы не ошиблись, то чекер должен выдать траекторию, где этот экшен будет взят. А, значит, наша спека проверяет такие исполнения.
* Так же удобно будет пользоваться "Error-Trace Exploration" - это поле находится в окошке, которое появляется, когда чекер находит неправильный трэйс. В него можно записать предикат, значения которого вы хотите посмотреть на всем пути исполнения ошибочного трейса. Например, сюда можно записать части экшена, в котором вы сомневаетесь и посмотреть чему они равны в каждом из состояний на неправильном трейсе.
* Еще одинм полезным способом может оказаться отладочный вывод. Можно в юбой экшен дописать /\ PrintT(smth) и во время взятия этого экшена чекером в консоль будет писаться значение выражения smth. По моему опыту это полезно для отлаживания проверки определенных св-в.

Пример: [LIN](https://github.com/lorin/tla-linearizability/blob/6a919f81f41ce43c884b87dde0976143b80d35db/LinQueue.tla#L31). Можно выводить состояние очереди на каждом шаге.

Для проверки модели этот способ не так хорош, экшен может браться б.м. раз и по выводу сложно понять, что происходит.

## Приемы для оптимизации
*
