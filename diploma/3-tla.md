# Часть 3 (TLA+)
## Тестирование
### UnitTest
Методы тестирования для спек, экшенов, предикатов и т.д.

### Unit tests
Полезно писать юнит-тесты для ваших операторов.
Пример:
* [1](https://github.com/pron/amazon-snapshot-spec/blob/9c60cb18151889d7b4c0a4ffd7de0b6fc2db0fb2/textbookSnapshotIsolation.tla#L673)
* [2]https://github.com/pron/amazon-snapshot-spec/blob/9c60cb18151889d7b4c0a4ffd7de0b6fc2db0fb2/textbookSnapshotIsolation.tla#L789

Чтобы запустить их и посмотреть, что все работает надо:
 1) В секции TLC "What is the behavior spec?", выбрать "No Behavior Spec"
 2) В "Evaluate Constant Expression" написать название юнит-теста

### Поиск поведения
Обязательно надо проверять, что в нашем графе существует нетривиальная траектория, которая захватывает нужный нам экшен. Это можно сделать просто написав св-во, которое будет верно только для этого поведения. Например, в спеке про репликацию в КХ можно проверить, что есть траектория, которая захватывает экшен, когда лидер назначает мердж.

DoMerge == <>(\E record \in Range(log): record.type = "Merge").

Можем проверить, отрицания (так как без честности могут быть поведения, где этот экшен не берется) этого экшена и удостовериться, что TLC выдаст нам траекторию, где такое произойдет. Для этого надо добавить в инварианты проверку отрицания нашего предиката и TLC покажет историю, которая ему удовлетворяет.

Аналогично можно поступить, когда надо понять, что генерируется необычная последовательность событий. Для этого достаточно написать предикат, которому удовлетворяет наше поведение.

Пример: в спеке SI автор [ищет](https://github.com/pron/amazon-snapshot-spec/blob/9c60cb18151889d7b4c0a4ffd7de0b6fc2db0fb2/textbookSnapshotIsolation.tla#L1191) поведения, которые удовлетворяют ReadOnlyAnomaly.

### Проверка истории
Большинство св-в нацелены на проверку истории действий, которые произвела наша система. Разработчики хотят проверять инварианты, которые наша система должна обеспечивать. Для проверки этих инвариантов надо промоделировать хранить историю, которую порождает исполнение. Для этого логично использовать tuple, куда надо сохранять события, которые произошли в системе (например действия транзакций, начало и конец вставок в DataStore и т.д.). С помощью этой служебной переменной мы сможем проверять интересующие нас инварианты. Для работы с историей будет удобно [написать](https://github.com/pron/amazon-snapshot-spec/blob/9c60cb18151889d7b4c0a4ffd7de0b6fc2db0fb2/textbookSnapshotIsolation.tla#L204) *правильное название*, чтобы работать с определенным типом событий только

Например: [SI](https://github.com/pron/amazon-snapshot-spec/blob/9c60cb18151889d7b4c0a4ffd7de0b6fc2db0fb2/textbookSnapshotIsolation.tla#L876) проверяется правило FirstCommitterWins (нет закомиченных транзакций, которые были конкурирующие и записывали одинаковые ключи)

### Мутационоое тестирование
После того, как алгоритм прошел проверку на наши тесты и удовлетворяет св-вам. Нам надо удостовериться, что наши проверки делают что-то полезное. Надо проверить, что тесты действительно тестируют что-то не тривиальное.

Используем мутационное тестирование для проверки тестов и св-в. Надо заменить какую-то важную часть алгоритма для нашего инварианта на противоположную и проверить, что наши инварианты будут нарушены.

Например: в спеке FPaxos можно изменить системы кворумов. На второй фазе MCQuorum2 == {{a1, a3},{a2, a4}} -> {{a1},{a2, a4}}, таким образом, мы нарушим одно из самых главных правил этого алгоритма, что кворумы между фазами должны пересекаться (для работы надо удалить вот [эту](https://github.com/fpaxos/fpaxos-tlaplus/blob/c562667ad96bcb9e07a30417a45b49c5d21d1fbe/FPaxos.tla#L6) проверку).

Если мы запустим TLC, то увидим, что у нас нарушилось [св-во](https://github.com/fpaxos/fpaxos-tlaplus/blob/c562667ad96bcb9e07a30417a45b49c5d21d1fbe/FPaxos.tla#L89). Так как теперь система кворумов из второй фазы пересекается не со всей системой кворумов из первой фазы, алгоритм смог принять 2 разных значения для разных кворумов. Вышло это из-за того, что у нас есть кворум, участники которого не пересекаются ни с одним из acceptor-ов одного из кворумов из первой фазы ( {{a1, a2},{a3, a4}} именно кворум {a1} и кворум {a3, a4}).

## TypeOk
В TLA+ есть несколько базовых типов данных. Создатель TLA+ Лампорт в своей [статье](https://lamport.azurewebsites.net/pubs/lamport-types.pdf) описывает, почему он выбрал нетипизированную систему. Лампорт в TLA не выбрал строго-типизированный язык, так как проверка типов может создать излишнюю сложность при написании формальной спецификации. Языки программирования используют типы для проверки на стадии компиляции. Строгие типы помогают отловить класс ошибок, которые могут произойти во время работы программы, но перед нами задач абстрактно описать наш алгоритм. Мы будем использовать теорию мн-в вместе с проверкой типов, что создаст дополнительное условие для проверки TLC.

"If a specification language is to be general, it must be expressive. No simple type system is as expressive as untyped set theory. While a simple type system can allow many specifications to be written easily, it will make some impossible to write and others more complicated than they would be in set theory."

Для того, чтобы TLC проверял, что значения переменных находятся в рамках заявленных типов надо создать дополнительный экшен, который надо добавить в Invariants (чтобы он проверялся на каждом шаге алгоритма)

Примеры:
* [SI](https://github.com/pron/amazon-snapshot-spec/blob/9c60cb18151889d7b4c0a4ffd7de0b6fc2db0fb2/serializableSnapshotIsolation.tla#L207)
* [Kafka](https://github.com/hachikuji/kafka-specification/blob/3cc3cf6914f76573f8b66fb700f8b90ac7ca8bed/KafkaReplication.tla#L101)
* [Paxos](https://github.com/fpaxos/fpaxos-tlaplus/blob/c562667ad96bcb9e07a30417a45b49c5d21d1fbe/FPaxos.tla#L27)

Рекомендации по написанию TypeOK:
* Для пользовательских структур надо определить тип для каждого поля из структуры. Для этого надо можно ввести TypeMyStrucInv, с помощью которого сгенерировать все возможные значения, которые может принимать ваша структура (Это делается [a: {...}, b: {2, 3}, ...], такая запись генерирует сет со всеми возможными значениями. Если одно из значений не set, то стоит использовать "->" [a -> 1, b: {2, 3}, ...]). В инварианте проверять, что ваша переменная \in во всех возможных значениях
* Если значения типа Tuple, то можно сгенерировать сет с помощью оператора Range(smth) и проверить, что этот сет является подмножеством всех возможных значений.
* Основная идея в том, чтобы определить сет со всеми возможными значениями пользовательской структуры, и на каждом шаге TLC будет проверять, что переменная принимает валидное значение..

## Бесконечная и конечная спека
Кол-во возможных исполнений системы часто бывает бесконечной. То есть TLC будет проверять все возможные исполнения нашей системы и не завершится. Работать с бесконечной спекой неудобно. Так как проверка liveness св-в не имеет смысла, так как tlc не может сообщить нам, что все поведения удовлетворяют нашему св-ву. Следовательно, мы должны ограничить длину истории и кол-во шагов нашего алгоритма.
Чтобы TLC работал с конечной спекой надо уметь запрещать бесконечные поведения.

Примеры:
* Kafka: [ограничили](https://github.com/hachikuji/kafka-specification/blob/3cc3cf6914f76573f8b66fb700f8b90ac7ca8bed/KafkaReplication.tla#L32) длину лога, кол-во эпох
* SI: [ограничили](https://github.com/pron/amazon-snapshot-spec/blob/9c60cb18151889d7b4c0a4ffd7de0b6fc2db0fb2/textbookSnapshotIsolation.tla#L31) кол-во транзакций

Таким образом мы запретили бесконечно ходить по графу конфигураций. Но вместе с этим появляется проблема, что tlc начинает обнаруживать дедлоки, если мы явно не моделируем завершения алгоритма. Это означает, что  ENABLED (Next) = false, так как на самом последнем шаге он не может выполнить никакое действие, но это не имеет ничего общего с дедлоком самого алгоритма. Чтобы с этим бороться можно создать экшен, который отвечает за конец работы алгоритма. Пример в [SI](https://github.com/pron/amazon-snapshot-spec/blob/9c60cb18151889d7b4c0a4ffd7de0b6fc2db0fb2/textbookSnapshotIsolation.tla#L568). В самом конце чекер перейдет в этот экшен и начнет в нем заикаться. Таким образом, tlc сможет находить дедлок нашего алгоритма, но не будет реагировать на конец работы алгоритма.

## SW и WF
safety св-ва в нашей системе ничего не говорят нам о будущем и о том, что должно произойти в нем. Чекер просто в каждом состоянии проверяет получившуюся формулу на св-ва, которые мы описали в системе. Нет никакого знания о будущем и траектории, которую надо выбрать.

Все меняется, когда мы хотим потребовать от нашей спецификации liveness св-ва. Тут мы вводим св-ва, которые будут верны когда-то в будущем. Сам чекер ничего не знает о том, что может пройзойти дальше. Он может выбирать траектории, которые образуют цикл.

Стоит сказать, что в графе конфигураций могут быть циклы или петли. Чекер проверит все наши траектории на выполнение наших св-в. В любой момент проверки он не знает, что может случиться в будущем.

liveness св-ва о прогрессе нашей системы. Они говорят о том, что алгоритм движется вперед, а не стоит на месте. Когда мы пишем liveness св-ва мы хотим, чтобы к нашей системе планировщик/OS относилась честно и мы будем прогрессировать, если сможем. В TLA+ мы должны явно указать какие переходы надо делать, когда они будут верны. Мы не убираем недетерминированный выбор. Алгорит или OS все равно могут делать недетерминированные шаги, но мы хотим подсказать чекеру, какие шаги ему надо делать "честно".

В TLA есть 2 оператора для обеспечения честности шагов алгоритма:
* WF - Если переход в экшен A есть из каждого состояния цикла, то мы точно перейдем в A
* SF - Если экшен A выполнен бесконечно-часто, то оно будет выполнено. То есть если мы попали в цикл в нашем графе конфигураций и есть состояние в этом цикле из которого можно перейти в A, то мы выполним переход когда-то

! SF => WF !

Мы как будто разрешаем спецификации видеть будущее и принимать решения на выбор траектории.

Что на самом деле дает нам честность? Мы хотим ограничить траектории, которые не совершают какой-то прогресс. Например, какие-нибудь бесполезные поведения, которые могут происходить, но они не будут удовлетворять нашим требованием от системы. Похожий метод используют разработчики из статьи про "Как тестировать код". Прием в том, чтобы не исследовать поведения, которые нас не интересуют совсем, так как в них проблемы скорее всего не произойдет. Это все имеет место быть в реальном мире, так как мы не можем сказать OS какой из шагов ей сделать в текущий момент или какой шаг не делать никогда, но это не имеет смысла для проверки liveness св-в у нашего алгоритма. Мы хотим проверять инварианты относительно какого-то полезного поведения.
Пример: В спеки Kafka есть [честность](https://github.com/hachikuji/kafka-specification/blob/3cc3cf6914f76573f8b66fb700f8b90ac7ca8bed/KafkaTruncateToHighWatermark.tla#L44) у некоторых действий. Например, у нас может быть траектория, в которой нет лидера и, следовательно, чекер в такой ситуации не будет брать важные и системы не будет совершать "прогресс"  (принимать записи, или увеличивать метку записей, которые точно должны быть у всех реплик). Авторы хотят избежать таких "бесполезных" траекторий, так как св-ва на них проверять бессмысленно. Поэтому они дают экшену `BecomeLeader` приоритет.

## BFS/simulation
Как вообще проверяется спека на удовлетворение св-вам:
* BFS - по спеке строится граф конфигураций. Чекер используя BFS обходит его и проверяет св-ва. Это приближенная модель, так как есть способы улучшить этот подход (статья про чекер). В чем + такого обхода - если он найдет ошибку, то он выдаст трэйс минимальной длинны - это нам гарантирует BFS. Понятно, что такой способ может работать долго, так как граф конфигураций мужет быть очень большой и кол-во возможных поведений = exp(кол-во шагов). Для бесконечных спек мы должны руками ограничить глубину поиска или же сделать спеку конечной. Этот способ подойдет, когда мы хотим проверить инварианты нашего алгоритма и делаем его специально конечным, чтобы посмотреть, что выполняются и safety и liveness св-ва.
* Simulation mode - иногда мы хотим найти интересное поведение нашего алгоритма. Или найти трэйс, который не удовлетворяет какому-то св-ву. Для этого подойдет другой подход исследования графа конфигураций. В этом методе чекер рандомно выбирает шаги в траектории. Как только он дошел до самого конца, он повторит все заново. Этот метод не поможет проверить, что наша спека удовлетворяет всем св-вам.  которые мы описали, так как она не проводит полную проверку графа состояний.Так как ошибки в распределенных алгоритмах требуют большого кол-ва шагов, то не всегда полное исследование графа конфигураций будет полезно. Например, этот способ можно использовать чтобы найти ReadOnlyAnomaly в спеке SI.

## Почему мы вообще можем делать конечную спеку
Многие баги в распределенных системах требуют большого кол-ва шагов и очень сложны. иногда они могут долгое время не проявлять себя. Когда мы тестируем наши св-ва, то чекер обходит весь граф конфигураций и проверяет все возможные исполнения системы. Хотелось бы иметь возможность монотонно увеличивать участников и кол-во действие, которые они будут производить. Но в реальности никто так не делает.

Мы фиксируем небольшое кол-во сущностей, которые производят какие-то действия. Фиксируем кол-во действий, который они могут сделать над системой (например: длина лога в Kafka, кол-во acceptor в паксосе или кол-во транзакций в SI). Мы специально уменьшаем кол-во траекторий в графе состояний, чтобы чекер мог их все обойти и проверить liveness св-ва. Мы моделируем систему на каком-то определенном наборе, что по интуиции может снизить нам кол-во найденных проблем

Почему же все это работает: мы можем ограничить кол-во записей в логе или кол-во транзакций, так как проблемы в распределенных алгоритмах возникают по большей части не из-за кол-ва участников или длины лога. А из-за проблем с сетью или проблем с отказом нод. TLC проверит все исполнения с разным порядком доставки сообщений и разным кол-вом умерших узлов и промоделирует все возможные поведения этой системы. Вероятно, наш алгоритм корректен, если он успешно прошел проверку TLC, но утверждать точно это нельзя. Так как же можно проверить алгоритм, что он верен для конфигурации, которую используют в реальном мире.
