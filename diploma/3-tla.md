# Часть 3 (TLA+)
## Тестирование
Хоть описание системы происходит с помощью языка математики, и спека является логической формулой, все равно стоит задумываться о тестировании и чистоте написания кода. Важно использовать единый кодстайл, как и влюбом другом коде, тестировать каждую часть спеки, так как найти ошибку в формальном описании довольно сложно.

Каждое траектория в спеке - это бесконечный набор состояний системы, но это не значит, что она не пригодна для model checker-а. В основе TLC лежит обход в ширину графа состояний, из-за этого чекеру не страшно, что траектории бесконечные, так как они из себя представляют циклы разной длины, потому что мн-во состояний системы конечно.

### Unit tests
Полезно писать юнит-тесты для ваших операторов.
Пример:

    UnitTests_FindAllNodesInAnyCycle ==
        /\ FindAllNodesInAnyCycle({})                                                       = {}
        /\ FindAllNodesInAnyCycle({<<"a", "b">>})                                           = {}
        /\ FindAllNodesInAnyCycle({<<"a", "b">>, <<"b", "c">>, <<"c", "d">>})               = {}                   (* no cycle, more nodes *)
        /\ FindAllNodesInAnyCycle({<<"a", "a">>})                                           = {"a"}                (* cycle of length 1 *)
        /\ FindAllNodesInAnyCycle({<<"a", "b">>, <<"b", "a">>})                             = {"a", "b"}           (* cycle of length 2 *)
        /\ FindAllNodesInAnyCycle({<<"a", "b">>, <<"b", "c">>, <<"c", "d">>, <<"d", "a">>}) = {"a", "b", "c", "d"} (* cycle of length 3 *)
        /\ FindAllNodesInAnyCycle({<<"a", "a">>, <<"b", "b">>})                             = {"a", "b"}           (* multiple disjoint cycles of length 1*)
        /\ FindAllNodesInAnyCycle({<<"a", "d">>, <<"d", "b">>, <<"c", "d">>, <<"d", "c">>}) = {"d", "c"}           (* cycles plus some nodes not in any cycle but which join to a cycle *)
        /\ FindAllNodesInAnyCycle({<<"a", "b">>, <<"b", "a">>, <<"c", "c">>, <<"d", "c">>}) = {"a", "b", "c"}      (* multiple disjoint cycles including length > 1 *)

        UnitTest_WellFormedTransactionsInHistory ==
                 (* must begin *)
            /\   WellFormedTransactionsInHistory(<<[op |-> "begin", txnid |-> "T_1"]>>)
                 (* just begin & commit *)
            /\   WellFormedTransactionsInHistory(<<[op |-> "begin", txnid |-> "T_1"], [op |-> "commit", txnid |-> "T_1"]>>)
                 (* begin, readX, writeY, commit *)
            /\   WellFormedTransactionsInHistory(<<[op |-> "begin", txnid |-> "T_1"], [op |-> "read", txnid |-> "T_1", key |-> "K_X", ver |-> "T_2"], [op |-> "write", txnid |-> "T_1", key |-> "K_Y"], [op |-> "commit", txnid |-> "T_1"]>>)
                 (* begin, readX, writeX, abort *)
            /\   WellFormedTransactionsInHistory(<<[op |-> "begin", txnid |-> "T_1"], [op |-> "read", txnid |-> "T_1", key |-> "K_X", ver |-> "T_2"], [op |-> "write", txnid |-> "T_1", key |-> "K_X"], [op |-> "abort", txnid |-> "T_1", reason |-> "voluntary"]>>)
            (* Negative tests *)
                 (* begin out of place *)
            /\ ~ WellFormedTransactionsInHistory(<<[op |-> "write", txnid |-> "T_1", key |-> "K_X"], [op |-> "begin", txnid |-> "T_1"]>>)
                 (* multiple begin *)
            /\ ~ WellFormedTransactionsInHistory(<<[op |-> "begin", txnid |-> "T_1"], [op |-> "begin", txnid |-> "T_1"], [op |-> "write", txnid |-> "T_1", key |-> "K_X"]>>)
                 (* commit out of place (after a begin of a different transaction) *)
            /\ ~ WellFormedTransactionsInHistory(<<[op |-> "begin", txnid |-> "T_1"], [op |-> "commit", txnid |-> "T_1"], [op |-> "write", txnid |-> "T_1", key |-> "K_X"]>>)
                 (* abort out of place *)
            /\ ~ WellFormedTransactionsInHistory(<<[op |-> "begin", txnid |-> "T_1"], [op |-> "abort", txnid |-> "T_1", reason |-> "voluntary"], [op |-> "write", txnid |-> "T_1", key |-> "K_X"]>>)
                 (* Violation of Bernstein's simplification: multiple writes to same key *)
            /\ ~ WellFormedTransactionsInHistory(<<[op |-> "begin", txnid |-> "T_1"], [op |-> "write", txnid |-> "T_1", key |-> "K_X"], [op |-> "write", txnid |-> "T_1", key |-> "K_X"]>>)
                 (* Violation of Bernstein's simplification: multiple reads of same key *)
            /\ ~ WellFormedTransactionsInHistory(<<[op |-> "begin", txnid |-> "T_1"], [op |-> "read", txnid |-> "T_1", key |-> "K_X", ver |-> "T_2"], [op |-> "read", txnid |-> "T_1", key |-> "K_X", ver |-> "T_2"]>>)

"Запустить" их можно так:
 1) В секции TLC "What is the behavior spec?", выбрать "No Behavior Spec"
 2) В "Evaluate Constant Expression" написать название юнит-теста

### Поиск поведения
После написания спеки надо удостовериться, что в ней существую нетривиалные траектории, которые захватывают наиболее важные для нас экшены.

Например:
* В SI можно проверить, что транзакции вообще начинаются и некоторые выполняются. Так как только тогда можно говорить о каких-нибкдь св-вах
* В Paxos можно проверить, что вторая фаза алгоритма вообще происходит.

Это можно сделать просто написав св-во, которое будет верно только для этого плохого поведения.

Например, в спеке про репликацию в КХ можно проверить, что мерджи назначаются. Для этого будем проверять, что в любом поведении нет мерджей

DoNotMerge == [](\A record \in Range(log): record.type != "Merge").

Дальше надо model checker запустить c проверкой этого св-ва, и если все реализовано правильно, то TLC выдаст нам траекторию, где такого не проиходит. А она, в свою очередь, будет гарантировать, что экшен будет взят.

Аналогично можно поступить, когда надо понять, что генерируется необычная последовательность событий. Для этого достаточно написать предикат, которому удовлетворяет наше поведение.

Пример: в спеке SI автор ищет поведения, которые удовлетворяют ReadOnlyAnomaly.

    ReadOnlyAnomaly(h) ==
            (* current history is not serializable *)
        /\  ~ CahillSerializable(h)
            (* and there is a transaction that does some reads and zero writes,
               and when that transaction is entirely removed from the history,
                   the resulting history is serializable. *)
        /\ \E txn \in TxnId :
                LET keysReadWritten == KeysReadAndWrittenByTxn(h, txn)
                IN
                    /\ Cardinality(keysReadWritten[1]) > 0
                    /\ Cardinality(keysReadWritten[2]) = 0
                    /\ CahillSerializable(HistoryWithoutTxn(h, txn))

Тесты для нашей спецификации можно оценить с помощью метрики "покрытие кода". Надо удостовериться, что все экшены будут взяты. Все операторы работаю правильно.

### Мутационоое тестирование
Мутационное тестирование (мутационный анализ или мутация программ) — это метод тестирования программного обеспечения, который включает небольшие изменения кода программы. Если набор тестов не в состоянии обнаружить такие изменения, то он рассматривается как недостаточный.

После того, как алгоритм прошел проверку на наши тесты и удовлетворяет св-вам. Нам надо удостовериться, что наши проверки действительно проверяют требуемые св-ва, а не тестируют что-то тривиальное, для этого надо заменить какую-то произвольную часть алгоритма и убедиться, что тесты отловят это.

Например: в спеке FPaxos можно изменить системы кворумов. В основе алгоритма лежит. На второй фазе MCQuorum2 == {{a1, a3},{a2, a4}} -> {{a1},{a2, a4}}. После этого надо запустить провреку и увидим, что у нас нарушилось св-во.

    Agreed(v,b) == \E Q \in Quorum2: \A a \in Q: Sent2b(a,v,b)
    NoFutureProposal(v,b) == \A v2 \in Value: \A b2 \in Ballot: (b2 > b /\ Sent2a(v2,b2)) => v=v2

    SafeValue == \A v \in Value: \A b \in Ballot: Agreed(v,b) => NoFutureProposal(v,b)

Св-во *SafeValue* (да и сам алгоритм Паксоса) построен на том, что кворум из первый фазы точно пересечется с кворумом из второй фазы хотя бы по одному acceptor-у, и тем самым будет обнаружено ранее предложенное значение. (для работы надо удалить ASSUME). А мы убрали этот инвариант и алгоритм смог принять 2 значения.

Подобные ограничения в TLA формулируют в виде assumption.

Например:
* FPaxos
    ASSUME QuorumAssumption == /\ \A Q \in Quorum1 : Q \subseteq Acceptor
                            /\ \A Q \in Quorum2 : Q \subseteq Acceptor
                            /\ \A Q1 \in Quorum1 : \A Q2 \in Quorum2 : Q1 \cap Q2 # {}

* Kafka
    ASSUME
        /\ None \notin Replicas
        /\ MaxLeaderEpoch \in Nat

### Проверка истории
Большинство св-в нацелены на проверку истории действий, которые произвела наша система. Разработчики хотят проверять инварианты, которые наша система должна обеспечивать. Для проверки этих инвариантов надо промоделировать хранить историю, которую порождает исполнение. Для этого логично использовать tuple, куда надо сохранять события, которые произошли в системе (например действия транзакций, начало и конец вставок в DataStore и т.д.). С помощью этой служебной переменной мы сможем проверять интересующие нас инварианты. Для работы с историей будет удобно написать операторы, чтобы работать с определенным типом событий только

    ActiveOrFinalizedTxns(h) == {e.txnid : e \in Range(h)}        (* all transactions apart from those that have not yet started *)
    NotYetStartedTxns(h)     == TxnId \ ActiveOrFinalizedTxns(h)
    CommittedTxns(h)         == {e.txnid : e \in SelectEvents(h, LAMBDA e : e.op \in {"commit"})}
    AbortedTxns(h)           == {e.txnid : e \in SelectEvents(h, LAMBDA e : e.op \in {"abort"})}
    FinalizedTxns(h)         == CommittedTxns(h) \union AbortedTxns(h)
    ActiveTxns(h)            == ActiveOrFinalizedTxns(h) \ FinalizedTxns(h)

Например: В SI проверяется правило FirstCommitterWins (нет закомиченных транзакций, которые были конкурирующие и записывали одинаковые ключи)

    FirstCommitterWins ==
        (* There are no committed transactions that were concurrent, and whose write-sets (keys) intersect. *)
        ~ \E t1, t2 \in CommittedTxns(history) :
            /\ t1 /= t2
            /\ AreConcurrent(history, t1, t2)
            /\             KeysThatTxnHasDoneOperationOn(history, t1, "write")
                \intersect KeysThatTxnHasDoneOperationOn(history, t2, "write")
                    /= {}

## TypeOk
В TLA+ использует нетипизированную систему мн-в, создатель TLA+ Лампорт в своей статье ["Should Your Specification Language Be Typed?"](https://lamport.azurewebsites.net/pubs/lamport-types.pdf) описывает, почему он сделал такой выбор. Лампорт в TLA+ не выбрал строго-типизированный язык, так как проверка типов может создать излишнюю сложность при написании формальной спецификации. Языки программирования используют типы для проверки на стадии компиляции. Строгие типы помогают отловить класс ошибок, которые могут произойти во время работы программы, но они сильно усложняют язык и накладывают ограничения. TLA+ использует теорию мн-в вместе с проверкой типов, что создаст дополнительное условие для проверки TLC и помогает отловить класс ошибок.

"If a specification language is to be general, it must be expressive. No simple type system is as expressive as untyped set theory. While a simple type system can allow many specifications to be written easily, it will make some impossible to write and others more complicated than they would be in set theory."

Для того, чтобы TLC проверял, что значения переменных находятся в рамках заявленных типов надо создать инвариант, который будет проверяться model checker-ом в каждом состоянии трейса.

Примеры:
* [SI]
    TypeInv ==  /\ history            \in Seq(EventsT)
                   (* A transaction may hold indepedent exclusive locks on any number of keys *)
                /\ holdingXLocks      \in [TxnId -> SUBSET Key]
                   (* A transaction can be waiting for at most one exclusive lock *)
                /\ waitingForXLock    \in [TxnId -> Key \union {NoLock}]
                /\ inConflict         \in [TxnId -> BOOLEAN]
                /\ outConflict        \in [TxnId -> BOOLEAN]
                /\ holdingSIREADlocks \in [TxnId -> SUBSET Key]
* Kafka
    TypeOk ==
        /\ LeaderEpochSeq!TypeOk
        /\ RecordSeq!TypeOk
        /\ ReplicaLog!TypeOk
        /\ replicaState \in [Replicas -> ReplicaState]
        /\ quorumState \in QuorumState
        /\ leaderAndIsrRequests \subseteq QuorumState
* Paxos
    TypeOK == /\ maxBal \in [Acceptor -> Ballot \cup {-1}]
              /\ maxVBal \in [Acceptor -> Ballot \cup {-1}]
              /\ maxVal \in [Acceptor -> Value \cup {None}]
              /\ msgs \subseteq Message

Рекомендации по написанию TypeOK:
* Основная идея в том, чтобы определить сет со всеми возможными значениями пользовательской структуры, и в каждом состоянии TLC будет проверять, что переменная принимает валидное значение.
* Для пользовательских структур надо определить тип для каждого поля из структуры. Для этого надо можно ввести TypeMyStrucInv, с помощью которого сгенерировать все возможные значения, которые может принимать ваша структура (Это делается [a: {...}, b: {2, 3}, ...], такая запись генерирует мн-во со всеми возможными значениями. Если одно из значений не мн-во, то стоит использовать "->" [a -> 1, b: {2, 3}, ...]). В инварианте проверять, что переменная \in во всех возможных значениях
* Если значения типа Tuple, то можно сгенерировать сет с помощью оператора Range(smth) и проверить, что этот сет является подмножеством всех возможных значений.

## Бесконечная и конечная спека
Кол-во возможных состояний в выполнении алогиртма - бесконечно, из-за инвариантоности относительно заикания. model checker исследует бесконечное число состояний внутри каждого поведения. Проверку liveness св-в нельзя запускать на траекториях с бесконечным числом состояний. Поэтому мы хотим для каждого их поведенияы ограничить число возможных состояний, что запускать tlc. Чтобы это сделать надо сделать конечное число возможных действий у системы:


Примеры:
* Kafka:
    CONSTANTS
        Replicas,
        LogSize,
        MaxRecords,
        MaxLeaderEpoch
ограничили длину лога, кол-во эпох
* SI:
    CONSTANTS TxnId, Key
ограничили кол-во транзакций

Введя ограничения на длину событий в системе, мы ограничили глубину в графе состояний. Таким образом мы могли получить состояние, откуда не существует перехода в другой экшен, так как все события уже произошли. Если запустить TLC, то он найдет дедлок (это ситуация, когда из состояния нет следующих доступных переходов), когда попытается выполнить переход из "плохого" состояния. Но этот дедлок никак не связан с дедлоком алгоритма, так как система просто завершился. Лампорт пишет: "A deadlock is said to occur in a state for which the next-state relation allows no successor states.  Termination is deadlock that is not considered an error.  If you want the behavior spec to allow termination, then you should uncheck the deadlock option." Но никто не хочет отключать одну из важных проверок для системы, поэтому воспользуемся трюком из спеки SI.

Чтобы избежать ложных срабатываний, надо создать экшен, в который наша система может перейти после завершения всех основных действий и в нем б.м. заикаться, таким образом мы избавимся от дедлока.

Пример в [SI]:
    LegitimateTermination ==  FinalizedTxns(history) = TxnId

## BFS/simulation
TLC использует явную проверку моделей, он исследует весь граф состояния с помощью обхода в ширину. Для проверки инвариантов во время обхода каждое состояние проверяется на удовлетворение написанным св-вам. Иногда не надо полностью исследовать граф састояний, а достаточно найти какое-то интересное поведение.

У TLC есть 2 режима:
* BFS - Чекер используя BFS обходит граф конфигураций системы и проверяет св-ва. Это приближенная модель, так как есть способы улучшить этот подход (статья про чекер). В чем + такого обхода - если  model checker находит обишку, то он выдает контрпример минимальной длины - это нам гарантирует BFS.

Пример: В [презентации](http://tla2012.loria.fr/contributed/newcombe-slides.pdf) авторы говорят, что в статье про readOnly аномалию в SI авторы приводят пример из 10 шагов, а model checker находит контрпример длины 9.

Понятно, что такой способ линеен от кол-ва состояний (кол-во состояний = exp(кол-во шагов)). Для бесконечных спек мы должны сделать спеку конечной. Этот способ подойдет, когда мы проверяем, что выполняются и safety и liveness св-ва.
* Simulation mode - Большинство багов распределенных систем требуют большой длины трейса. При запуске TLC в обычном режиме потребуется сначала исследовать все короткие трейсы перед тестированием более длинных. Для поиска "интересных" поведений можно воспольщоваться не систематическим исследованием графа конфигураций, а Simulation mode. В этом методе чекер случайно выбирает траекторию и исследует ее на выполнение св-вам. Этот метод не поможет проверить, что наша спека удовлетворяет всем св-вам, которые мы описали, так как он не проводит полную проверку графа состояний.

Например, этот способ можно использовать чтобы найти ReadOnlyAnomaly в спеке SI.

## Почему мы вообще можем делать конечную спеку
С помощью TLC можно проверить только небольшие модели, в которых число proposal-ов в Basic Paxos, транзакций в Percolator, аппендов в Kafka измеряется единицами (3-5), в то время как в реалной системе их на многие порядки больше.

Это происходит, потому что мы явно исследуем граф состояний - для проверки инвариантов нам нужно обойти каждое достижимое состояние, а для проверки произвольных темпоральных свойств – явно разложить весь граф в памяти и найти в нем сильно связные компоненты, а размер графа будет экспоненциально зависеть от значений упомянутых выше параметров, так как

Тем не менее, model checking даже для таких небольших моделей может убеждать в корректности.

Примеры:
* Контрпример для Basic Paxos: аксепта одного значения на большинстве узлов недостаточно для понятия выбора - достаточно 4 proposal-ов
* Баги в lf алгоритмах чаще всего можно промоделировать на очень небольшом числе потоков, независимо от сложности самого бага, пример с длинным багом в lf аллокаторе
* RO аномалия для SI достигается на 3 транзакциях и 2 ключах

В статье "https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-yuan.pdf" аторы исследовали баги, которые нашли пользователи, в 5-ти популярных распределенных системах (Cassandra, HBase, HDFS, MapReduce, Redi) и они заметили: "Almost all (98%) of the failures are guaranteed to manifest on no more than 3 nodes. 84% will manifest on no more than 2 nodes…. It is not necessary to have a large cluster to test for and reproduce failures."

Таким образом, большинство багов в распределенных системах требуют большого кол-ва шагов, но могут проявляться при небольшом кол-ве участников.

## SW и WF
safety св-ва в нашей системе ничего не говорят нам о будущем и о том, что должно произойти в нем. Чекер просто в каждом состоянии проверяет получившуюся формулу на св-ва, которые мы описали в системе. Нет никакого знания о будущем и траектории, которую надо выбрать.

Все меняется, когда мы хотим потребовать от нашей спецификации liveness св-ва. Тут мы вводим св-ва, которые будут верны когда-то в будущем. Сам чекер ничего не знает о том, что может пройзойти дальше. Он может выбирать траектории, которые образуют цикл.

Стоит сказать, что в графе конфигураций могут быть циклы или петли. Чекер проверит все наши траектории на выполнение наших св-в. В любой момент проверки он не знает, что может случиться в будущем.

liveness св-ва о прогрессе нашей системы. Они говорят о том, что алгоритм движется вперед, а не стоит на месте. Когда мы пишем liveness св-ва мы хотим, чтобы к нашей системе планировщик/OS относилась честно и мы будем прогрессировать, если сможем. В TLA+ мы должны явно указать какие переходы надо делать, когда они будут верны. Мы не убираем недетерминированный выбор. Алгорит или OS все равно могут делать недетерминированные шаги, но мы хотим подсказать чекеру, какие шаги ему надо делать "честно". Но для большинства распределенных систем liveness св-ва не проверяются.

В TLA есть 2 оператора для обеспечения честности шагов алгоритма:
* WF - Если переход в экшен A есть из каждого состояния цикла, то мы точно перейдем в A
* SF - Если экшен A выполнен бесконечно-часто, то оно будет выполнено. То есть если мы попали в цикл в нашем графе конфигураций и есть состояние в этом цикле из которого можно перейти в A, то мы выполним переход когда-то

! SF => WF !

Мы как будто разрешаем спецификации видеть будущее и принимать решения на выбор траектории.

Что на самом деле дает нам честность? Мы хотим ограничить траектории, которые не совершают какой-то прогресс. Например, какие-нибудь бесполезные поведения, которые могут происходить, но они не будут удовлетворять нашим требованием от системы. Похожий метод используют разработчики из статьи про "Как тестировать код". Прием в том, чтобы не исследовать поведения, которые нас не интересуют совсем, так как в них проблемы скорее всего не произойдет. Это все имеет место быть в реальном мире, так как мы не можем сказать OS какой из шагов ей сделать в текущий момент или какой шаг не делать никогда, но это не имеет смысла для проверки liveness св-в у нашего алгоритма. Мы хотим проверять инварианты относительно какого-то полезного поведения.
Пример: В спеки Kafka есть [честность](https://github.com/hachikuji/kafka-specification/blob/3cc3cf6914f76573f8b66fb700f8b90ac7ca8bed/KafkaTruncateToHighWatermark.tla#L44) у некоторых действий.

Например:
    Spec == Init /\ [][Next]_vars
                 /\ SF_vars(LeaderIncHighWatermark)
                 /\ SF_vars(LeaderExpandIsr)
                 /\ SF_vars(LeaderWrite)
                 /\ WF_vars(BecomeFollowerTruncateToHighWatermark)
                 /\ WF_vars(BecomeLeader)

у нас может быть траектория, в которой нет лидера и, следовательно, чекер в такой ситуации не будет брать важные и системы не будет совершать "прогресс"  (принимать записи, или увеличивать метку записей, которые точно должны быть у всех реплик). Авторы хотят избежать таких "бесполезных" траекторий, так как св-ва на них проверять бессмысленно. Поэтому они дают экшену `BecomeLeader` приоритет.
