# Часть 3 (TLA+)
## Тестирование
### UnitTest
Хочется проверять, что функции делают то, что надо. Для этого полезно писать юнит-тесты. Пример можно посмотреть в [SI](https://github.com/pron/amazon-snapshot-spec/blob/9c60cb18151889d7b4c0a4ffd7de0b6fc2db0fb2/textbookSnapshotIsolation.tla#L673). Чтобы запустить их и посмотреть, что все работает надо:
 1) В секции TLC "What is the behavior spec?", выбрать "No Behavior Spec"
 2) В "Evaluate Constant Expression" написать название юнит-теста

### Поведения
Иногда хочется понять, генерируется ли какое-нибудь не тривиальное поведение или найти необычную последовательность событий. Для этого достаточно написать предикат, которому удовлетворяет наше поведение. После этого в проверяемы инварианты (которые верны на каждом шагу исполнения) надо записать наш предикат с отрицанием "~". TLC найдет интересующее нас поведение и выдаст нам trace для него. Например, в спеке SI автор [ищет](https://github.com/pron/amazon-snapshot-spec/blob/9c60cb18151889d7b4c0a4ffd7de0b6fc2db0fb2/textbookSnapshotIsolation.tla#L1191) поведения, которые удовлетворяют ReadOnlyAnomaly. Для проверки liveness св-в нам стоит завести историю событий, которую порождает исполнение. Обычно это tuple, куда записываются события, которые произошли в системе (например действия транзакций, начало и конец вставок в DataStore и т.д.). С помощью этой служебной переменной мы сможем проверять интересующие нас инварианты.

*Что-то про историю написать?*

! Важно, что для проверки liveness св-в мы должны запретить бесконечные траектории у нашего алгоритма. То есть мы должны ограничить длину истории и кол-во шагов работы алгоритма.

### Мутационоое тестирование
Мы проверили наш алгоритм с помощью каких-то св-в и тестов. Но как нам удостовериться, что наши тесты вообще делают что-то полезное? Как понять, что мы написали что-то не тривиальное?

Используем мутационное тестирование для проверки тестов и св-в. Надо заменить какую-то важную часть алгоритма на противоположную и проверить, что наши инварианты будут нарушены.

Например: в спеке FPaxos можно изменить системы кворумов. Например, на второй фазе MCQuorum2 == {{a1, a3},{a2, a4}} -> {{a1},{a2, a4}}, то есть мы нарушили правило, что кворумы из первой фазы пересекаются с кворумами из второй.
P.S. надо удалть вот [эту](https://github.com/fpaxos/fpaxos-tlaplus/blob/c562667ad96bcb9e07a30417a45b49c5d21d1fbe/FPaxos.tla#L6) проверку.

Если мы запустим TLC, то увидим, что у нас сломалось [св-во](https://github.com/fpaxos/fpaxos-tlaplus/blob/c562667ad96bcb9e07a30417a45b49c5d21d1fbe/FPaxos.tla#L89). Вышло это из-за того, что у нас теперь сет кворумов, который не пересекается ни с кем из acceptor-ов одного кворума из первой фазы. Таким образом у нас получилось принять 2 разных значения, что нарушает главное св-во алгоритма (agreement).

## TypeOk
В TLA+ есть несколько базовых типов данных, в отличие от многих языков программирования. Создатель TLA+ Лампорт в своей [статье](https://lamport.azurewebsites.net/pubs/lamport-types.pdf). Лампорт в TLA выбрал систему нетипизированную теорию мн-в, а не строго-типизированный язык, которые могут создать излишнюю сложность при написании формальной спецификации. Языки программирования используют типы для проверки на стадии компиляции. Строгие типы помогают отловить класс ошибок, которые могут произойти во время работы программы, но перед нами задач абстрактно описать наш алгоритм. Мы будем использовать теорию мн-в вместе с проверкой типов, что создаст дополнительные условия на верность экшенов.

Для того, чтобы TLC проверял, что вы значения переменных находятся в рамках заявленных типов надо создать дополнительный экшен, который надо добавить в Invariants (чтобы он проверялся на каждом шаге алгоритма)

Примеры:
* [SI](https://github.com/pron/amazon-snapshot-spec/blob/9c60cb18151889d7b4c0a4ffd7de0b6fc2db0fb2/serializableSnapshotIsolation.tla#L207)
* [Kafka](https://github.com/hachikuji/kafka-specification/blob/3cc3cf6914f76573f8b66fb700f8b90ac7ca8bed/KafkaReplication.tla#L101)
* [Paxos](https://github.com/fpaxos/fpaxos-tlaplus/blob/c562667ad96bcb9e07a30417a45b49c5d21d1fbe/FPaxos.tla#L27)

Рекомендации по написанию TypeOK:
* Для пользовательских структур надо определить тип для каждого поля из структуры. Для этого надо можно ввести TypeMyStrucInv, с помощью которого сгенерировать все возможные значения, которые может принимать ваша структура (Это делается [a: {...}, b: {2, 3}, ...], такая запись генерирует сет со всеми возможными значениями. Если одно из значений не set, то стоит использовать "->" [a -> 1, b: {2, 3}, ...]). В инварианте проверять, что ваша переменная \in во всех возможных значениях
* Если значения типа Tuple, то можно сгенерировать сет с помощью оператора Range(smth) и проверить, что этот сет является подмножеством всех возможных значений.
* Смысл в том, что вы определяете все возможные значения, которые может принимать ваша структура и проверяете, что на каждом шаге алгоритма она находится в этом сете.

## Бесконечная спека (дедлоки)
