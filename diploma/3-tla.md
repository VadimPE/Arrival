# Часть 3 (TLA+)

## Model Checker
Формальное описание системы переводится в граф конфигураций.

Граф конфигураций описывает все возможные выполнения нашей системы.

Model checker обходит этот граф, используя BFS, и в каждом состоянии проверяет заданные свойства.

## Почему мы можем рассматривать небольшие модели
Model checker явно исследует граф состояний - для проверки инвариантов ему нужно обойти каждое достижимое состояние, а для проверки произвольных темпоральных свойств – явно разложить весь граф в памяти и найти в нем сильно связные компоненты, а размер графа будет экспоненциально зависеть от значений упомянутых выше параметров. Из-за этого мы хотим уменьшить кол-во состояний системы и проверить наши свойства.

Поэтому разумно с помощью TLC проверять только небольшие модели в которых число участников/действий небольшое число. Например: proposal-ов в Basic Paxos, транзакций в Percolator, аппендов в Kafka измеряется единицами (3-5), в то время как в реалной системе их на многие порядки больше, так как число состояний = exp от параметров системы.

Тем не менее, model checking даже для таких небольших моделей может убеждать в корректности. Так как он полностью исследует все возможные выполнения системы.

Примеры:
* Контрпример для Basic Paxos: аксепта одного значения на большинстве узлов недостаточно для понятия выбора - достаточно 4 proposal-ов
* Баги в lf алгоритмах чаще всего можно промоделировать на очень небольшом числе потоков, независимо от сложности самого бага.
* RO аномалия для SI достигается на 3 транзакциях и 2 ключах

В статье "https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-yuan.pdf" аторы заметили: "Almost all (98%) of the failures are guaranteed to manifest on no more than 3 nodes. 84% will manifest on no more than 2 nodes…. It is not necessary to have a large cluster to test for and reproduce failures."

Заметим, что даже полная проверка на небольшой модели не может служить служить доказательством корректности в общем случае, но природа конкурентных багов такова, что они часто не зависят от кол-ва участников (если их больше 1), а зависят от порядка действий.

## BFS/simulation
В обычном TLC использует явную проверку моделей: исследует весь граф состояний системы с помощью обхода в ширину. Для проверки инвариантов во время обхода каждое состояние проверяется на удовлетворение написанным свойствам. Иногда не надо полностью исследовать граф састояний, а достаточно найти какое-то интересное поведение.

Чекер используя BFS обходит граф конфигураций системы и проверяет свойства. В чем + такого обхода - если  model checker находит обишку, то он выдает контрпример минимальной длины - это нам гарантирует BFS.

Пример: В [презентации](http://tla2012.loria.fr/contributed/newcombe-slides.pdf) описано как model checker смог найти пример для readOnly аномалии длины 9, а авторы приводят приводят пример из 10 шагов.

Понятно, что такой способ линеен от кол-ва состояний, а кол-во вершин в графе экспонециально от кол-во состояний узлов, так как если у нас a состояний и b компонент, то получается, что кол-во вершин в графе конфигураций = b^a. Для бесконечных спек мы должны сделать спеку конечной. Этот способ подойдет, когда мы проверяем, что выполняются свойства алгортима.

Большинство багов распределенных систем требуют большой длины трейса. При запуске TLC в обычном режиме потребуется сначала исследовать все короткие трейсы перед тестированием более длинных.

Для поиска "интересных" поведений можно воспольщоваться не систематическим исследованием графа конфигураций, а Simulation mode.

В этом методе чекер случайно выбирает траекторию и исследует ее на выполнение свойствам. Этот метод не поможет проверить, что наша спека удовлетворяет всем свойствам, которые мы описали, так как он не проводит полную проверку графа состояний.

Например, этот способ можно использовать чтобы найти ReadOnlyAnomaly в спеке SI.

## Бесконечная и конечная спека
Кол-во возможных состояний у распределенной системы - б.м., так как мы не говорим о ее завершении из-за свойства реактивности. От model checker-а ожидают разумное время на проверку нашей спеки, для этого надо сделать кол-во состояний конечным.

Чтобы добиться этого надо ограничить возможное число действий или узлов.

Примеры:

В Kafa-е ограничивается кол-во реплик и кол-во запросов от клиента.

    CONSTANTS
        Replicas,
        LogSize,
        MaxRecords,
        MaxLeaderEpoch

В SI ограничивают кол-во возможныз транзакций в алгоритме.

    CONSTANTS TxnId, Key

Мы могли получить состояние, откуда не бывает перехода в другой экшен, так как все события уже произошли.

Если запустить TLC, то он найдет состояние, из которого нет перехода в другие, в терминах TLC  - это дедлок.

Но это не означает дедлок алгоритма, а говорит только о конце работы системы.

Лампорт пишет: "A deadlock is said to occur in a state for which the next-state relation allows no successor states.  Termination is deadlock that is not considered an error.  If you want the behavior spec to allow termination, then you should uncheck the deadlock option."

Но никто не хочет отключать одну из важных проверок для системы, поэтому воспользуемся приемом из спеки SI.

Чтобы избежать “ложных” срабатываний, заведем дополнительный дизъюнкт в Next, который будет порождать явную петлю в состояниях, в которых исчерпаны ограниченные нами внешние события: клиентские запросы / транзакциии / proposal-ы, таким образом мы избавимся от технического дедлока.

Пример в [SI]:

    LegitimateTermination ==  FinalizedTxns(history) = TxnId

## Уменьшение состояний
В модели надо указать значение всех констант в системе.

Иногда константе можно дать какое-то определенное значение, но иногда требуется, чтобы это значение было уникальным и не равнялось ничему другому.

Например:

В Kafak или SI у нас есть набор участников системы. Мы могли бы сделать каждую реплику числом, но TLA+ позваляет дать уникальный индентификатор, который нигде больше не встретиться. Для этого используется model value

Мы можем заменить replicas <- {1, 2, 3} => replicas <- [model value]{r1, r2, r3}.

Если где-то в спеке будет написано что-то сложнее чем сравнение с этим значением, то TLC сообщит об этом.

Обычно такое требуется для названия узлов системы, или когда надо сделать константу NONE.

Когда одна из CONSTANT является множеством, то часто перестановка элементов в этом множестве не нарушит инварианты системы.

Это может помочь TLC уменьщить количество достижимых состояний, так как теперь состояния, которые различаются только порядком элементов этого сета будут считаться одинаковыми.

Для того, чтобы сделать это в IDE в разделе "Model Overview" в поле "What is the model" надо явно указать, что множество является symmetric.

Наборы симетрии не могут использоваться, когда мы хотим проверять liveness свойства. Так как теперь мы не рассматриваем все состояния системы и могли удалить те из них, где liveness св-во нарушается или наоборот выполняется.

## Тестирование
Хотя спецификация системы в TLA+ и является логической формулой, к ней все применимы критерии качества и техники работы с программным кодом. Если спека достаточно велика (как, например, Snapshot Isolation), то эти техники становятся жизненно необходимыми. Важно использовать единый кодстайл, писать комментарии, поясняющие действие сложных экшенов, тестировать помимо свойств моделируемой системы саму спеку.

### Юнит-тестирование
Полезно писать юнит-тесты для отдельных нетривиальных операторов из которых потом строятся свойства.

Пример:

Например, в спеке SI юнит тесты проверяют, что оператор FindAllNodesInAnyCycle обнаруживает цикл в графе конфликтующих транзакций. Этот оператор используется для тестирование свойства сериализуемости, которое описывает, как упорядочиваются конкурирующие транзакции.

    UnitTests_FindAllNodesInAnyCycle ==
        /\ FindAllNodesInAnyCycle({})                                                       = {}
        /\ FindAllNodesInAnyCycle({<<"a", "b">>})                                           = {}
        /\ FindAllNodesInAnyCycle({<<"a", "b">>, <<"b", "c">>, <<"c", "d">>})               = {}
        ...

Следующие тесты проверяют, что спецификация пораждает валидные истории исполнения транзакций: каждая транзакция в истории проходит через шаги Begin -> [Write|Read] -> Abort|Commit.


    UnitTest_WellFormedTransactionsInHistory ==
             (* must begin *)
        /\   WellFormedTransactionsInHistory(<<[op |-> "begin", txnid |-> "T_1"]>>)
        /\ ~ WellFormedTransactionsInHistory(<<[op |-> "write", txnid |-> "T_1", key |-> "K_X"], [op |-> "begin", txnid |-> "T_1"]>>)
             (* multiple begin *)
        /\ ~ WellFormedTransactionsInHistory(<<[op |-> "begin", txnid |-> "T_1"], [op |-> "begin", txnid |-> "T_1"], [op |-> "write", txnid |-> "T_1", key |-> "K_X"]>>)
        ...

"Запустить" тесты можно так:
 1) В секции TLC "What is the behavior spec?", выбрать "No Behavior Spec"
 2) В "Evaluate Constant Expression" написать название юнит-теста

### Покрытия кода
Полезно убедиться, что спека порождает нетривиальные траектории и покрывает написанные экшены. В противном случае тестировать какие-либо инварианты почти бесполезно.

Заметим, что на самом деле таким образом мы проверяем покрытие кода в спеке и убеждаемся, что все экшены будут взяты.

Например:
* В SI можно проверить, что транзакции вообще начинаются и некоторые выполняются. Так как только тогда можно говорить о каких-нибкдь свойствах
* В Paxos можно проверить, что вторая фаза алгоритма вообще происходит.

Проверить наличие нетривиальных траекторий можно с помощью свойства-инварианта, которое описывает траектории, где наш экшен не будет браться.

Запуск model checker c проверкой этого свойства должен выдать нам траекторию, где такого не проиходит, если все реализовано правильно. А она, в свою очередь, будет гарантировать, что экшен будет взят.

Аналогично можно поступить, когда надо понять, что генерируется необычная последовательность событий

Пример:

В спеке SI автор ищет поведения, которые удовлетворяют ReadOnlyAnomaly.

    ReadOnlyAnomaly(h) ==
            (* current history is not serializable *)
        /\  ~ CahillSerializable(h)
            (* and there is a transaction that does some reads and zero writes,
               and when that transaction is entirely removed from the history,
                   the resulting history is serializable. *)
        /\ \E txn \in TxnId :
                LET keysReadWritten == KeysReadAndWrittenByTxn(h, txn)
                IN
                    /\ Cardinality(keysReadWritten[1]) > 0
                    /\ Cardinality(keysReadWritten[2]) = 0
                    /\ CahillSerializable(HistoryWithoutTxn(h, txn))

В спеке про репликацию в КХ можно проверить, что мерджи назначаются. Для этого будем проверять, что в любом поведении нет мерджей

    DoNotMerge == [](\A record \in Range(log): record.type != "Merge")

Разработчик TLC работает на встроенным профилированием в IDE, чтобы не писать такие инварианты самому.

### Мутационоое тестирование
Мутационное тестирование  — это метод тестирования системы, при котором в программу небольшие деструктивные изменения, которые должны сломать тесты. Если этого не произошло, то тесты надо переделать.

В спеке поменять произовльную часть программы не получится. Вместо этого изменения вносятся в важные фрагменты спеки.

Вместо покрасневших тестов мы ожидаем, что TLC обнаружит нарушение свойств.

Например: в спеке FPaxos можно изменить системы кворумов. На второй фазе MCQuorum2 == {{a1, a3},{a2, a4}} -> {{a1},{a2, a4}}. После этого надо запустить провреку и увидим, что у нас нарушилось св-во *SafeValue*, так как алгоритм Паксоса построен на том, что кворум из первый фазы точно пересечется с кворумом из второй фазы хотя бы по одному acceptor-у, и тем самым будет обнаружено ранее предложенное значение. (для работы надо удалить ASSUME). А мы убрали этот инвариант и алгоритм смог принять 2 значения.

Подобные ограничения в TLA формулируют в виде assumption.

Например:
FPaxos

    ASSUME QuorumAssumption == /\ \A Q \in Quorum1 : Q \subseteq Acceptor
                            /\ \A Q \in Quorum2 : Q \subseteq Acceptor
                            /\ \A Q1 \in Quorum1 : \A Q2 \in Quorum2 : Q1 \cap Q2 # {}

Kafka

    ASSUME
        /\ None \notin Replicas
        /\ MaxLeaderEpoch \in Nat

### TypeOk
*В TLA+ использует нетипизированную теорию мн-в, создатель TLA+ Лампорт в своей статье ["Should Your Specification Language Be Typed?"](https://lamport.azurewebsites.net/pubs/lamport-types.pdf) описывает, почему он сделал такой выбор. Лампорт в TLA+ не выбрал строго-типизированный язык, так как проверка типов может создать излишнюю сложность при написании формальной спецификации. Языки программирования используют типы для проверки на стадии компиляции. Строгие типы помогают отловить класс ошибок, которые могут произойти во время работы программы, но они сильно усложняют язык и накладывают ограничения.*
TLA+ использует теорию мн-в вместе с проверкой типов, что создает дополнительное условие для проверки TLC и помогает отловить класс ошибок.

"If a specification language is to be general, it must be expressive. No simple type system is as expressive as untyped set theory. While a simple type system can allow many specifications to be written easily, it will make some impossible to write and others more complicated than they would be in set theory."

Полезно ввести технический инвариант, который будет проверять не свойства системы, а корректность модели – что значения переменных, которые образуют состояния системы, принимают значения определенного типа, который мы используем в реализации.

Как правило в TypeOk описан сетевой протокол, то есть все возможные сообщения, которыми могут обмениваться ноды:

Paxos:

    Message ==      [type : {"1a"}, bal : Ballot]
               \cup [type : {"1b"}, acc : Acceptor, bal : Ballot,
                     mbal : Ballot \cup {-1}, mval : Value \cup {None}]
               \cup [type : {"2a"}, bal : Ballot, val : Value]
               \cup [type : {"2b"}, acc : Acceptor, bal : Ballot, val : Value]

Raft:

    ReplicaState == [hw : ReplicaLog!Offsets \union {LogSize},
                     leaderEpoch: LeaderEpochOpt,
                     leader : ReplicaOpt,
                     isr: SUBSET Replicas]

Примеры TypeOk:
SI

    TypeInv ==  /\ history            \in Seq(EventsT)
                   (* A transaction may hold indepedent exclusive locks on any number of keys *)
                /\ holdingXLocks      \in [TxnId -> SUBSET Key]
                   (* A transaction can be waiting for at most one exclusive lock *)
                /\ waitingForXLock    \in [TxnId -> Key \union {NoLock}]
                /\ inConflict         \in [TxnId -> BOOLEAN]
                /\ outConflict        \in [TxnId -> BOOLEAN]
                /\ holdingSIREADlocks \in [TxnId -> SUBSET Key]
Kafka

    TypeOk ==
        /\ LeaderEpochSeq!TypeOk
        /\ RecordSeq!TypeOk
        /\ ReplicaLog!TypeOk
        /\ replicaState \in [Replicas -> ReplicaState]
        /\ quorumState \in QuorumState
        /\ leaderAndIsrRequests \subseteq QuorumState
Paxos

    TypeOK == /\ maxBal \in [Acceptor -> Ballot \cup {-1}]
              /\ maxVBal \in [Acceptor -> Ballot \cup {-1}]
              /\ maxVal \in [Acceptor -> Value \cup {None}]
              /\ msgs \subseteq Message

Для пользовательских структур надо определить тип для каждого поля из структуры. Для этого надо сгенерировать все возможные значения, которые может принимать ваша структура (Это делается [a: {...}, b: {2, 3}, ...], такая запись генерирует мн-во со всеми возможными значениями. Если одно из значений не мн-во, то стоит использовать "->" [a -> 1, b: {2, 3}, ...]). В инварианте проверять, что переменная \in во всех возможных значениях

## Читаемый трейс
TLC умеет печатать трейс, который привел к ошибке. В нем идет перечесление всех VARIABLES, которые есть в системе. Но не всегда понятно, какому экшену соответсвует строчка. Для читаемости трейса Next представляется в виде простой дизъюнкции всех экшенов

Пример: Kafka

    Next ==
        \/ ControllerElectLeader
        \/ ControllerShrinkIsr
        \/ BecomeLeader
        \/ LeaderExpandIsr
        \/ LeaderShrinkIsr
        \/ LeaderWrite
        \/ LeaderIncHighWatermark
        \/ BecomeFollowerTruncateToHighWatermark
        \/ FollowerReplicate

При использовании такой записи в трейсе будет явно отражен, какой экшен был взят.

Такой способ стоит использовать не всегда.

Во время дебага спеки такая информативность полезна, так как это помогает быстро обнаружить, где произошла ошибка. Для читателя, который хочет с помощью спеки понять, как устроена система, будет удобней смотреть на экшены, которые относятся к определенным сущностям. Для этого можно объединить экшены одного участника

Например: у нас есть реплика, которая умеет читать запись в логе, становиться неактивной или еще что-то. Есть клиент, который умеет делать Insert или Select. Мы делаем экшен для них:

    ReplicaAction == \E replica \in Replicas: Action1(replica) \/ Action2(replica)

    ClientAction == Insert \/ Select

    Next ==
        \/ ReplicaAction
        \/ ClientAction

## TLC и командная строка
Кроме IDE TLC можно использовать из консоли.

Для того, чтобы использовать model checker из командной строкой надо:
* Установить TLA+.
* Установить bin-файл в вашу систему
* Создать фалй для тестировния MCMyspec.tla: В нем надо задать те параметры, которые вы передадите в CONSTANT для тестирования

    -------------------------------- MODULE MCFPaxos -------------------------------
    EXTENDS FPaxos, TLC
    -----------------------------------------------------------------------------
    CONSTANTS a1, a2, a3, a4  \* acceptors
    CONSTANTS v1, v2      \* Values

    MCAcceptor == {a1, a2, a3, a4}
    MCValue    == {v1, v2}
    MCQuorum1 == {{a1, a2},{a3, a4}}
    MCQuorum2 == {{a1, a3},{a2, a4}}
    MCBallot == 0..1

В нем определили константы для ключей и акцепторов и определили множества, которые использует сама спека)
* Создать конфигурационный файл для спеки. В катором будет оражение параметров из файла для тестирования в параметры спеки.
Пример

    SPECIFICATION Spec
    CONSTANTS
      a1=a1  a2=a2  a3=a3  a4=a4 v1=v1  v2=v2
      Acceptor <- MCAcceptor
      Value    <- MCValue
      Quorum1   <- MCQuorum1
      Quorum2   <- MCQuorum2
      Ballot   <- MCBallot
      None     =  None

    INVARIANT SafeValue TypeOK

Нас интересуют больше всего параметры: INVARIANTS (инварианты системы), PROPERTIES (liveness св-ва), CONSTANTS (отображение параметров), SPEC (сама спека)
* Чтобы запустить тестирование надо выполнть команду tlc MCMyspec.tla

Удобство от такого испольщования в том, что IDE генерирует файл для model checker-а в нечитаемом виде. Открыть его просто так и разобраться в нем - очень сложно. Для того, чтобы вашу спеку могли запустить с нужными параметрами, надо отдельно описывать настройки. А файл для командного tlc понятен и находится рядом со спекой
